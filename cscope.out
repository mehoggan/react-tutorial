cscope 15 $HOME/Devel/sandbox/webdev/react-tutorial -q 0000000975 0000218947
	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan.h

21 #ide
NAN_H_


22 
	#NAN_H_


	)

24 
	~<node_vsi.h
>

26 
	#NODE_0_10_MODULE_VERSION
 11

	)

27 
	#NODE_0_12_MODULE_VERSION
 14

	)

28 
	#ATOM_0_21_MODULE_VERSION
 41

	)

29 
	#IOJS_1_0_MODULE_VERSION
 42

	)

30 
	#IOJS_1_1_MODULE_VERSION
 43

	)

31 
	#IOJS_2_0_MODULE_VERSION
 44

	)

32 
	#IOJS_3_0_MODULE_VERSION
 45

	)

33 
	#NODE_4_0_MODULE_VERSION
 46

	)

34 
	#NODE_5_0_MODULE_VERSION
 47

	)

35 
	#NODE_6_0_MODULE_VERSION
 48

	)

36 
	#NODE_7_0_MODULE_VERSION
 51

	)

37 
	#NODE_8_0_MODULE_VERSION
 57

	)

38 
	#NODE_9_0_MODULE_VERSION
 59

	)

39 
	#NODE_10_0_MODULE_VERSION
 64

	)

40 
	#NODE_11_0_MODULE_VERSION
 67

	)

41 
	#NODE_12_0_MODULE_VERSION
 72

	)

42 
	#NODE_13_0_MODULE_VERSION
 79

	)

43 
	#NODE_14_0_MODULE_VERSION
 83

	)

45 #ifde
_MSC_VER


46 
	#NAN_HAS_CPLUSPLUS_11
 (
_MSC_VER
 >1800)

	)

48 
	#NAN_HAS_CPLUSPLUS_11
 (
__lulus
 >201103L)

	)

51 #i
NODE_MODULE_VERSION
 >
IOJS_3_0_MODULE_VERSION
 && !
NAN_HAS_CPLUSPLUS_11


52 #r 
This
 
vsi
 
of
 
node
/
NAN
/
v8
 
ques
 
a
 
C
++11 
comp


55 
	~<uv.h
>

56 
	~<node.h
>

57 
	~<node_bufr.h
>

58 
	~<node_obje_wp.h
>

59 
	~<gܙhm
>

60 
	~<crg
>

61 
	~<ims
>

62 
	~<cdlib
>

63 
	~<uty
>

64 #i
defed
(
_MSC_VER
)

65 #agm
wng

push
 )

66 #agm
wng

dib
 : 4530 )

67 
	~<queue
>

68 
	~<rg
>

69 
	~<ve
>

70 #agm
wng

p
 )

72 
	~<queue
>

73 
	~<rg
>

74 
	~<ve
>

78 #ifde
UV_VERSION_MAJOR


79 #ide
UV_VERSION_PATCH


80 
	#UV_VERSION_PATCH
 0

	)

82 
	#NAUV_UVVERSION
 ((
UV_VERSION_MAJOR
 << 16) | \

83 (
UV_VERSION_MINOR
 << 8) | \

84 (
UV_VERSION_PATCH
))

	)

86 
	#NAUV_UVVERSION
 0x000b00

	)

89 #i
NAUV_UVVERSION
 < 0x000b0b

90 #ifde
WIN32


91 
	~<wdows.h
>

93 
	~<had.h
>

97 
mea
 
	gN
 {

99 
	#NAN_CONCAT
(
a
, 
b

	`NAN_CONCAT_HELPER
, b)

	)

100 
	#NAN_CONCAT_HELPER
(
a
, 
b
a##
	)
b

102 
	#NAN_INLINE
 
le


103 

	)

104 #i
defed
(
__GNUC__
) && \

105 !(
defed
(
V8_DISABLE_DEPRECATIONS
&& 
	gV8_DISABLE_DEPRECATIONS
)

106 
	#NAN_DEPRECATED
 
	`__ibu__
((
dd
))

	)

107 #i
defed
(
_MSC_VER
) && \

108 !(
defed
(
V8_DISABLE_DEPRECATIONS
&& 
	gV8_DISABLE_DEPRECATIONS
)

109 
	#NAN_DEPRECATED
 
	`__deec
(
dd
)

	)

111 
	#NAN_DEPRECATED


	)

114 #i
NAN_HAS_CPLUSPLUS_11


115 
	#NAN_DISALLOW_ASSIGN
(
CLASS

ݔ
=(cڡ CLASS&
de
;

	)

116 
	#NAN_DISALLOW_COPY
(
CLASS

	`CLASS
(cڡ CLASS&
de
;

	)

117 
	#NAN_DISALLOW_MOVE
(
CLASS
) \

118 
	`CLASS
(
CLASS
&&
de
; \

119 
ݔ
=(
CLASS
&&
de
;

	)

121 
	#NAN_DISALLOW_ASSIGN
(
CLASS

ݔ
=(cڡ CLASS&);

	)

122 
	#NAN_DISALLOW_COPY
(
CLASS

	`CLASS
(cڡ CLASS&);

	)

123 
	#NAN_DISALLOW_MOVE
(
CLASS
)

	)

126 
	#NAN_DISALLOW_ASSIGN_COPY
(
CLASS
) \

127 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

128 
	`NAN_DISALLOW_COPY
(
CLASS
)

	)

130 
	#NAN_DISALLOW_ASSIGN_MOVE
(
CLASS
) \

131 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

132 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

134 
	#NAN_DISALLOW_COPY_MOVE
(
CLASS
) \

135 
	`NAN_DISALLOW_COPY
(
CLASS
) \

136 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

138 
	#NAN_DISALLOW_ASSIGN_COPY_MOVE
(
CLASS
) \

139 
	`NAN_DISALLOW_ASSIGN
(
CLASS
) \

140 
	`NAN_DISALLOW_COPY
(
CLASS
) \

141 
	`NAN_DISALLOW_MOVE
(
CLASS
)

	)

143 
	#TYPE_CHECK
(
T
, 
S
) \

144 
l
) { \

145 *(
ic_
<
T
 *vީ*>(0)ic_<
S
*>(0); \

146 }

	)

150 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


151 
	gv8
::
	tHd
<
	tv8
::
	tObje
> 
	tADDON_REGISTER_FUNCTION_ARGS_TYPE
;

153 
	gv8
::
	tLol
<
	tv8
::
	tObje
> 
	tADDON_REGISTER_FUNCTION_ARGS_TYPE
;

156 
	#NAN_MODULE_INIT
(
me
) \

157 
	`me
(
N
::
ADDON_REGISTER_FUNCTION_ARGS_TYPE
 
rg
)

	)

159 #i
NODE_MAJOR_VERSION
 >= 10 || \

160 
	gNODE_MAJOR_VERSION
 =9 && 
NODE_MINOR_VERSION
 >= 3

161 
	#NAN_MODULE_WORKER_ENABLED
(
modu_me
, 
giti
) \

162 "C" 
NODE_MODULE_EXPORT
 \

163 
	`NAN_CONCAT
(
node_gi_modu_v
, 
NODE_MODULE_VERSION
)( \

164 
v8
::
Lol
<v8::
Obje
> 
expts
, v8::Lol<v8::
Vue
> 
modu
, \

165 
v8
::
Lol
<v8::
Cڋxt
> 
cڋxt
) \

167 
	`giti
(
expts
); \

168 }

	)

170 
	#NAN_MODULE_WORKER_ENABLED
(
modu_me
, 
giti
) \

171 
	`NODE_MODULE
(
modu_me
, 
giti
)

	)

176 
	~"n_backs.h
"

180 #i(
NODE_MODULE_VERSION
 < 
NODE_0_12_MODULE_VERSION
)

181 
v8
::
	tSt
 
	tUnboundSt
;

182 
	gv8
::
	tSt
 
	tBoundSt
;

184 
	gv8
::
	tUnboundSt
 UnboundScript;

185 
	gv8
::
	tSt
 
	tBoundSt
;

188 #i(
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION
)

189 
	gv8
::
	tSg
::
	tExAsciiSgResour


190 
	tExOBySgResour
;

192 
	gv8
::
	tSg
::
	tExOBySgResour


193 
	tExOBySgResour
;

196 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

197 
	gme
<
tyme
 
	gT
>

198 
ass
 
	gNCyabPsitTs
 :

199 
public
 
v8
::
NCyabPsitTs
<
T
> {};

200 
	gme
<
tyme
 
	gT
>

201 
ass
 
	gCyabPsitTs
 :

202 
public
 
v8
::
CyabPsitTs
<
T
> {};

204 
	gme
<
tyme
 
	gT
>

205 
ass
 
	gPsitBa
 :

206 
public
 
v8
::
PsitBa
<
T
> {};

208 
	gme
<
tyme
 
	gT
,ym
	gM
 = 
v8
::
NCyabPsitTs
<
T
> >

209 
ass
 
Psit
;

211 
	gme
<
tyme
 
	gT
> 
ass
 
	gNCyabPsitTs
;

212 
	gme
<
tyme
 
	gT
> 
ass
 
	gPsitBa
;

213 
	gme
<
tyme
 
	gT
,ym
	gP
> 
ass
 
	gWkClbackDa
;

214 
	gme
<
tyme
 
	gT
,ym
	gM
 = 
NCyabPsitTs
<
T
> >

215 
ass
 
Psit
;

218 
	gme
<
tyme
 
	gT
>

219 as
	cMaybe
 {

220 
	gpublic
:

221 
le
 
bo
 
IsNhg
(cڡ {  !
has_vue_
; }

222 
le
 
bo
 
IsJu
(cڡ {  
	ghas_vue_
; }

224 
le
 
T
 
ToChecked
(cڡ {  
FromJu
(); }

225 
le
 
Check
(cڡ { 
FromJu
(); }

227 
le
 
bo
 
To
(
T
* 
out
) const {

228 i(
IsJu
()*
	gout
 = 
vue_
;

229  
IsJu
();

232 
le
 
T
 
FromJu
() const {

233 #i
defed
(
V8_ENABLE_CHECKS
)

234 
as
(
IsJu
() && "FromJust is Nothing");

236  
	gvue_
;

239 
le
 
T
 
FromMaybe
(cڡ T& 
deu_vue
) const {

240  
	ghas_vue_
 ? 
	gvue_
 : 
deu_vue
;

243 
le
 
bo
 
	gݔ
==(cڡ 
Maybe
 &
h
) const {

244  (
IsJu
(=
h
.IsJust()) &&

245 (!
IsJu
(|| 
FromJu
(=
h
.FromJust());

248 
le
 
bo
 
	gݔ
!=(cڡ 
Maybe
 &
h
) const {

249  !
ݔ
==(
h
);

252 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

253 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

255 
Maybe
(cڡ 
v8
::Maybe<
T
>& 
th
)

256 : 
has_vue_
(
th
.
IsJu
())

257 , 
vue_
(
th
.
FromMaybe
(
T
())) {}

260 
	give
:

261 
Maybe
(: 
has_vue_
(
l
) {}

262 
exic
 
Maybe
(cڡ 
T
& 
t
: 
has_vue_
(
ue
), 
vue_
(t) {}

263 
bo
 
	ghas_vue_
;

264 
T
 
	gvue_
;

266 
	gme
<
tyme
 
	gU
>

267 
nd
 
	gMaybe
<
	gU
> 
Nhg
();

268 
	gme
<
tyme
 
	gU
>

269 
nd
 
	gMaybe
<
	gU
> 
Ju
(cڡ 
U
& 
u
);

272 
	gme
<
tyme
 
	gT
>

273 
le
 
	gMaybe
<
	gT
> 
	$Nhg
() {

274  
Maybe
<
T
>();

275 
	}
}

277 
	gme
<
tyme
 
	gT
>

278 
le
 
	gMaybe
<
	gT
> 
	$Ju
(cڡ 
T
& 
t
) {

279  
Maybe
<
T
>(
t
);

280 
	}
}

282 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

283 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

284 
	~"n_maybe_43_l.h
"

286 
	~"n_maybe_e_43_l.h
"

289 
	~"n_cvrs.h
"

290 
	~"n_w.h
"

292 #i
NAUV_UVVERSION
 < 0x000b17

293 
	#NAUV_WORK_CB
(
func
) \

294 
	$func
(
uv_async_t
 *
async
, )

	)

296 
	#NAUV_WORK_CB
(
func
) \

297 
	$func
(
uv_async_t
 *
async
)

	)

300 #i
NAUV_UVVERSION
 >= 0x000b0b

302 
uv_key_t
 
	tuv_key_t
;

304 
le
 
	$uv_key_
(
uv_key_t
 *
key
) {

305  
	`uv_key_
(
key
);

306 
	}
}

308 
le
 
	$uv_key_de
(
uv_key_t
 *
key
) {

309 
	`uv_key_de
(
key
);

310 
	}
}

312 
le
 * 
	$uv_key_g
(
uv_key_t
 *
key
) {

313  
	`uv_key_g
(
key
);

314 
	}
}

316 
le
 
	$uv_key_t
(
uv_key_t
 *
key
, *
vue
) {

317 
	`uv_key_t
(
key
, 
vue
);

318 
	}
}

327 #ide
WIN32


329 
had_key_t
 
	tuv_key_t
;

331 
le
 
	$uv_key_
(
uv_key_t
* 
key
) {

332  -
	`had_key_
(
key
, 
NULL
);

333 
	}
}

335 
le
 
	$uv_key_de
(
uv_key_t
* 
key
) {

336 i(
	`had_key_de
(*
key
))

337 
	`abt
();

338 
	}
}

340 
le
 * 
	$uv_key_g
(
uv_key_t
* 
key
) {

341  
	`had_gecific
(*
key
);

342 
	}
}

344 
le
 
	$uv_key_t
(
uv_key_t
* 
key
, * 
vue
) {

345 i(
	`had_tecific
(*
key
, 
vue
))

346 
	`abt
();

347 
	}
}

352 
DWORD
 
	gs_dex
;

353 } 
	tuv_key_t
;

355 
le
 
	$uv_key_
(
uv_key_t
* 
key
) {

356 
key
->
s_dex
 = 
	`TlsAoc
();

357 i(
key
->
s_dex
 =
TLS_OUT_OF_INDEXES
)

358  
UV_ENOMEM
;

360 
	}
}

362 
le
 
	$uv_key_de
(
uv_key_t
* 
key
) {

363 i(
	`TlsFe
(
key
->
s_dex
=
FALSE
)

364 
	`abt
();

365 
key
->
s_dex
 = 
TLS_OUT_OF_INDEXES
;

366 
	}
}

368 
le
 * 
	$uv_key_g
(
uv_key_t
* 
key
) {

369 * 
vue
 = 
	`TlsGVue
(
key
->
s_dex
);

370 i(
vue
 =
NULL
)

371 i(
	`GLaE
(!
ERROR_SUCCESS
)

372 
	`abt
();

373  
vue
;

374 
	}
}

376 
le
 
	$uv_key_t
(
uv_key_t
* 
key
, * 
vue
) {

377 i(
	`TlsSVue
(
key
->
s_dex
, 
vue
=
FALSE
)

378 
	`abt
();

379 
	}
}

384 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


385 
	gme
<
tyme
 
	gT
>

386 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T>);

389 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

390 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

391 
v8
::
	tWkClbackTy
 WeakCallbackType;

393 
	sWkClbackTy
 {

394 
	eE
 {
	gkPam
, 
	gkIlFlds
};

395 
E
 
	gty
;

396 
WkClbackTy
(
E
 
h
: 
ty
(other) {}

397 
le
 
bo
 
ݔ
==(
E
 
h
{  oth =
this
->
ty
; }

398 
le
 
bo
 
	gݔ
!=(
E
 
h
{  !
ݔ
==(other); }

402 
	gme
<
tyme
 
	gP
> 
ass
 
	gWkClbackInfo
;

404 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


405 
	~"n_rsit_12_l.h
"

407 
	~"n_rsit_e_12_l.h
"

410 
mea
 
	gimp
 {

411 cڡ 
size_t
 
	gkMaxLgth
 = 0x3fffffff;

414 #i
NODE_MAJOR_VERSION
 > 0 || \

415 
	gNODE_MINOR_VERSION
 > 10 || \

416 
	gNODE_MINOR_VERSION
 =10 && 
NODE_PATCH_VERSION
 >= 29 || \

417 
NODE_MINOR_VERSION
 =8 && 
NODE_PATCH_VERSION
 >= 27

418 cڡ 
kRInvidUtf8
 = 
v8
::
Sg
::
REPLACE_INVALID_UTF8
;

420 cڡ 
	gkRInvidUtf8
 = 0;

426 as
	cHdSce
 {

427 
	gv8
::
HdSce
 
sce
;

429 
	gpublic
:

430 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


431 
le
 
HdSce
(: 
sce
(
v8
::
Isީe
::
GCut
()) {}

432 
le
 
NumbOfHds
() {

433  
v8
::
HdSce
::
NumbOfHds
(v8::
Isީe
::
GCut
());

436 
le
 
HdSce
(: 
sce
() {}

437 
le
 
NumbOfHds
() {

438  
v8
::
HdSce
::
NumbOfHds
();

442 
	give
:

445 
HdSce
(const HandleScope &);

446 
	gݔ
=(cڡ 
HdSce
 &);

447 *
ݔ
 
w
(
size_t
 
size
);

448 
ݔ
 
de
(*, 
size_t
) {

449 
abt
();

453 as
	cEsbHdSce
 {

454 
	gpublic
:

455 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


456 
le
 
EsbHdSce
(: 
sce
(
v8
::
Isީe
::
GCut
()) {}

458 
le
 
NumbOfHds
() {

459  
v8
::
EsbHdSce
::
NumbOfHds
(v8::
Isީe
::
GCut
());

462 
	gme
<
tyme
 
	gT
>

463 
le
 
	gv8
::
Lol
<
T
> 
Es
(
v8
::Lol<T> 
vue
) {

464  
sce
.
Es
(
vue
);

467 
	give
:

468 
v8
::
EsbHdSce
 
sce
;

470 
le
 
EsbHdSce
(: 
sce
() {}

472 
le
 
NumbOfHds
() {

473  
v8
::
HdSce
::
NumbOfHds
();

476 
	gme
<
tyme
 
	gT
>

477 
le
 
	gv8
::
Lol
<
T
> 
Es
(
v8
::Lol<T> 
vue
) {

478  
sce
.
Clo
(
vue
);

481 
	give
:

482 
v8
::
HdSce
 
sce
;

485 
	give
:

488 
EsbHdSce
(const EscapableHandleScope &);

489 
	gݔ
=(cڡ 
EsbHdSce
 &);

490 *
ݔ
 
w
(
size_t
 
size
);

491 
ݔ
 
de
(*, 
size_t
) {

492 
abt
();

498 as
	cTryCch
 {

499 
	gv8
::
TryCch
 
y_tch_
;

500 
nd
 
FExi
(cڡ 
TryCch
&);

502 
	gpublic
:

503 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


504 
TryCch
(: 
y_tch_
(
v8
::
Isީe
::
GCut
()) {}

507 
le
 
bo
 
HasCaught
(cڡ {  
y_tch_
.HasCaught(); }

509 
le
 
bo
 
CCtue
(cڡ {  
	gy_tch_
.CanContinue(); }

511 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
ReThrow
() {

512 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


513  
New
(
y_tch_
.
ReThrow
());

515  
	gy_tch_
.
ReThrow
();

519 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
Exi
() const {

520  
y_tch_
.
Exi
();

523 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

524 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

525 
le
 
v8
::
MaybeLol
<v8::
Vue
> 
SckT
() const {

526 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

527 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

528  
	gsce
.
Es
(
y_tch_
.
SckT
(
isީe
->
GCutCڋxt
())

529 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

532 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
SckT
() const {

533  
y_tch_
.
SckT
();

537 
le
 
	gv8
::
Lol
<
v8
::
Mesge
> Message() const {

538  
y_tch_
.
Mesge
();

541 
le
 
Ret
({ 
	gy_tch_
.Reset(); }

543 
le
 
SVbo
(
bo
 
vue
{ 
	gy_tch_
.SetVerbose(value); }

545 
le
 
SCtuMesge
(
bo
 
vue
) {

546 
	gy_tch_
.
SCtuMesge
(
vue
);

550 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(v8::Lol<v8::
Obje
> 
rg
,

551 
v8
::
Lol
<v8::
Funi
> 
func
,

552 
gc
,

553 
v8
::
Lol
<v8::
Vue
>* 
gv
);

554 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(v8::Lol<v8::
Obje
> 
rg
,

555 
v8
::
Lol
<v8::
Sg
> 
symb
,

556 
gc
,

557 
v8
::
Lol
<v8::
Vue
>* 
gv
);

558 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(v8::Lol<v8::
Obje
> 
rg
,

559 cڡ * 
mhod
,

560 
gc
,

561 
v8
::
Lol
<v8::
Vue
>* 
gv
);

565 as
	cAsyncResour
 {

566 
	gpublic
:

567 
AsyncResour
(

568 
v8
::
Lol
<v8::
Sg
> 
me


569 , 
v8
::
Lol
<v8::
Obje
> 
sour
 = 
New
<v8::Object>()) {

570 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


571 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
GCut
();

573 i(
	gsour
.
IsEmy
()) {

574 
	gsour
 = 
New
<
v8
::
Obje
>();

577 
	gcڋxt
 = 
node
::
EmAsyncIn
(
isީe
, 
sour
, 
me
);

581 
AsyncResour
(

582 cڡ * 
me


583 , 
v8
::
Lol
<v8::
Obje
> 
sour
 = 
New
<v8::Object>()) {

584 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


585 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
GCut
();

587 i(
	gsour
.
IsEmy
()) {

588 
	gsour
 = 
New
<
v8
::
Obje
>();

591 
	gv8
::
Lol
<
v8
::
Sg
> 
me_rg
 =

592 
New
<
v8
::
Sg
>(
me
).
ToLolChecked
();

593 
	gcڋxt
 = 
node
::
EmAsyncIn
(
isީe
, 
sour
, 
me_rg
);

597 ~
AsyncResour
() {

598 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


599 
	gv8
::
Isީe
* 
isީe
 = 
v8
::Isީe::
GCut
();

600 
	gnode
::
EmAsyncDeroy
(
isީe
, 
cڋxt
);

604 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
runInAsyncSce
(

605 
v8
::
Lol
<v8::
Obje
> 
rg


606 , 
v8
::
Lol
<v8::
Funi
> 
func


607 , 
gc


608 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

609 #i
NODE_MODULE_VERSION
 < 
NODE_9_0_MODULE_VERSION


610  
MakeClback
(
rg
, 
func
, 
gc
, 
gv
);

612  
	gnode
::
MakeClback
(

613 
v8
::
Isީe
::
GCut
(), 
rg
, 
func
, 
gc
, 
gv
, 
cڋxt
);

617 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
runInAsyncSce
(

618 
v8
::
Lol
<v8::
Obje
> 
rg


619 , 
v8
::
Lol
<v8::
Sg
> 
symb


620 , 
gc


621 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

622 #i
NODE_MODULE_VERSION
 < 
NODE_9_0_MODULE_VERSION


623  
MakeClback
(
rg
, 
symb
, 
gc
, 
gv
);

625  
	gnode
::
MakeClback
(

626 
v8
::
Isީe
::
GCut
(), 
rg
, 
symb
, 
gc
, 
gv
, 
cڋxt
);

630 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
runInAsyncSce
(

631 
v8
::
Lol
<v8::
Obje
> 
rg


632 , cڡ * 
mhod


633 , 
gc


634 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

635 #i
NODE_MODULE_VERSION
 < 
NODE_9_0_MODULE_VERSION


636  
MakeClback
(
rg
, 
mhod
, 
gc
, 
gv
);

638  
	gnode
::
MakeClback
(

639 
v8
::
Isީe
::
GCut
(), 
rg
, 
mhod
, 
gc
, 
gv
, 
cڋxt
);

643 
	give
:

644 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
AsyncResour
)

645 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


646 
node
::
async_cڋxt
 
cڋxt
;

650 
le
 
uv_lo_t
* 
	$GCutEvtLo
() {

651 #i
NODE_MAJOR_VERSION
 >= 10 || \

652 
NODE_MAJOR_VERSION
 =9 && 
NODE_MINOR_VERSION
 >= 3 || \

653 
NODE_MAJOR_VERSION
 =8 && 
NODE_MINOR_VERSION
 >= 10

654  
node
::
	`GCutEvtLo
(
v8
::
Isީe
::
	`GCut
());

656  
	`uv_deu_lo
();

658 
	}
}

663 #i
NODE_MODULE_VERSION
 >
NODE_0_12_MODULE_VERSION


664 
le


665 
	$SCouFuni
(
v8
::
CouLookupClback
 
cb
) {

666 
v8
::
Isީe
::
	`GCut
()->
	`SCouFuni
(
cb
);

667 
	}
}

669 
le


670 
	$SCeHiogmFuni
(
v8
::
CeHiogmClback
 
cb
) {

671 
v8
::
Isީe
::
	`GCut
()->
	`SCeHiogmFuni
(
cb
);

672 
	}
}

674 
le


675 
	$SAddHiogmSameFuni
(
v8
::
AddHiogmSameClback
 
cb
) {

676 
v8
::
Isީe
::
	`GCut
()->
	`SAddHiogmSameFuni
(
cb
);

677 
	}
}

679 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

680 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

681 
le
 
bo
 
	$IdNifiti
(
id_time__ms
) {

682  
v8
::
Isީe
::
	`GCut
()->
	`IdNifitiDdle
(

683 
id_time__ms
 * 0.001);

684 
	}
}

686 
le
 
bo
 
	$IdNifiti
(
id_time__ms
) {

687  
v8
::
Isީe
::
	`GCut
()->
	`IdNifiti
(
id_time__ms
);

688 
	}
}

691 
le
 
	$LowMemyNifiti
() {

692 
v8
::
Isީe
::
	`GCut
()->
	`LowMemyNifiti
();

693 
	}
}

695 
le
 
	$CڋxtDiodNifiti
() {

696 
v8
::
Isީe
::
	`GCut
()->
	`CڋxtDiodNifiti
();

697 
	}
}

699 
le


700 
	$SCouFuni
(
v8
::
CouLookupClback
 
cb
) {

701 
v8
::
V8
::
	`SCouFuni
(
cb
);

702 
	}
}

704 
le


705 
	$SCeHiogmFuni
(
v8
::
CeHiogmClback
 
cb
) {

706 
v8
::
V8
::
	`SCeHiogmFuni
(
cb
);

707 
	}
}

709 
le


710 
	$SAddHiogmSameFuni
(
v8
::
AddHiogmSameClback
 
cb
) {

711 
v8
::
V8
::
	`SAddHiogmSameFuni
(
cb
);

712 
	}
}

714 
le
 
bo
 
	$IdNifiti
(
id_time__ms
) {

715  
v8
::
V8
::
	`IdNifiti
(
id_time__ms
);

716 
	}
}

718 
le
 
	$LowMemyNifiti
() {

719 
v8
::
V8
::
	`LowMemyNifiti
();

720 
	}
}

722 
le
 
	$CڋxtDiodNifiti
() {

723 
v8
::
V8
::
	`CڋxtDiodNifiti
();

724 
	}
}

727 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

728 
le
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Undefed
() {

729 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


730 
EsbHdSce
 
sce
;

731  
sce
.
	`Es
(
	`New
(
v8
::
	`Undefed
(v8::
Isީe
::
	`GCut
())));

733  
v8
::
	`Undefed
(v8::
Isީe
::
	`GCut
());

735 
	}
}

737 
le
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Nu
() {

738 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


739 
EsbHdSce
 
sce
;

740  
sce
.
	`Es
(
	`New
(
v8
::
	`Nu
(v8::
Isީe
::
	`GCut
())));

742  
v8
::
	`Nu
(v8::
Isީe
::
	`GCut
());

744 
	}
}

746 
le
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$True
() {

747 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


748 
EsbHdSce
 
sce
;

749  
sce
.
	`Es
(
	`New
(
v8
::
	`True
(v8::
Isީe
::
	`GCut
())));

751  
v8
::
	`True
(v8::
Isީe
::
	`GCut
());

753 
	}
}

755 
le
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$F
() {

756 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


757 
EsbHdSce
 
sce
;

758  
sce
.
	`Es
(
	`New
(
v8
::
	`F
(v8::
Isީe
::
	`GCut
())));

760  
v8
::
	`F
(v8::
Isީe
::
	`GCut
());

762 
	}
}

764 
le
 
	gv8
::
Lol
<
v8
::
Sg
> 
	$EmySg
() {

765  
v8
::
Sg
::
	`Emy
(v8::
Isީe
::
	`GCut
());

766 
	}
}

768 
le
 
	$AdjuExMemy
(
bc
) {

769  
ic_
<>(

770 
v8
::
Isީe
::
	`GCut
()->
	`AdjuAmouOfExAodMemy
(
bc
));

771 
	}
}

773 
le
 
STeme
(

774 
v8
::
Lol
<v8::
Teme
> 
m


775 , cڡ *
me


776 , 
v8
::
Lol
<v8::
Da
> 
vue
) {

777 
m
->
S
(
v8
::
Isީe
::
GCut
(), 
me
, 
vue
);

780 
le
 
STeme
(

781 
v8
::
Lol
<v8::
Teme
> 
m


782 , 
v8
::
Lol
<v8::
Sg
> 
me


783 , 
v8
::
Lol
<v8::
Da
> 
vue


784 , 
v8
::
PrݔtyAribu
 
ibus
) {

785 
m
->
S
(
me
, 
vue
, 
ibus
);

788 
le
 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
	$GCutCڋxt
() {

789  
v8
::
Isީe
::
	`GCut
()->
	`GCutCڋxt
();

790 
	}
}

792 
le
 * 
GIlFldPor
(

793 
v8
::
Lol
<v8::
Obje
> 
obje


794 , 
dex
) {

795  
	gobje
->
GAligdPorFromIlFld
(
dex
);

798 
le
 
SIlFldPor
(

799 
v8
::
Lol
<v8::
Obje
> 
obje


800 , 
dex


801 , * 
vue
) {

802 
	gobje
->
SAligdPorInIlFld
(
dex
, 
vue
);

805 
	#NAN_GC_CALLBACK
(
me
) \

806 
	$me
(
v8
::
Isީe
 *
isީe
, v8::
GCTy
 
ty
, v8::
GCClbackFgs
 
ags
)

	)

808 #i
NODE_MODULE_VERSION
 <
NODE_4_0_MODULE_VERSION


809 
v8
::
	tIsީe
::
	tGCEpogueClback
 GCEpilogueCallback;

810 
v8
::
	tIsީe
::
	tGCProgueClback
 GCPrologueCallback;

812 
v8
::
	tIsީe
::
	tGCClback
 
	tGCEpogueClback
;

813 
v8
::
	tIsީe
::
	tGCClback
 
	tGCProgueClback
;

816 
le
 
	$AddGCEpogueClback
(

817 
GCEpogueClback
 
back


818 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

819 
v8
::
Isީe
::
	`GCut
()->
	`AddGCEpogueClback
(
back
, 
gc_ty_fr
);

820 
	}
}

822 
le
 
	$RemoveGCEpogueClback
(

823 
GCEpogueClback
 
back
) {

824 
v8
::
Isީe
::
	`GCut
()->
	`RemoveGCEpogueClback
(
back
);

825 
	}
}

827 
le
 
	$AddGCProgueClback
(

828 
GCProgueClback
 
back


829 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

830 
v8
::
Isީe
::
	`GCut
()->
	`AddGCProgueClback
(
back
, 
gc_ty_fr
);

831 
	}
}

833 
le
 
	$RemoveGCProgueClback
(

834 
GCProgueClback
 
back
) {

835 
v8
::
Isީe
::
	`GCut
()->
	`RemoveGCProgueClback
(
back
);

836 
	}
}

838 
le
 
	$GHpStiics
(

839 
v8
::
HpStiics
 *
hp_iics
) {

840 
v8
::
Isީe
::
	`GCut
()->
	`GHpStiics
(
hp_iics
);

841 
	}
}

843 
	#X
(
NAME
) \

844 
le
 
v8
::
Lol
<v8::
Vue
> 
	$NAME
(cڡ *
msg
) { \

845 
EsbHdSce
 
sce
; \

846  
sce
.
	`Es
(
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

847 
	}
} \

849 
le
 \

850 
v8
::
Lol
<v8::
Vue
> 
	`NAME
(v8::Lol<v8::
Sg
> 
msg
) { \

851  
v8
::
Exi
::
	`NAME
(
msg
); \

854 
le
 
Throw
 ## 
	$NAME
(cڡ *
msg
) { \

855 
HdSce
 
sce
; \

856 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
( \

857 
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

858 
	}
} \

860 
le
 
Throw
 ## 
	`NAME
(
v8
::
Lol
<v8::
Sg
> 
msg
) { \

861 
HdSce
 
sce
; \

862 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
( \

863 
v8
::
Exi
::
	`NAME
(
msg
)); \

864 }

	)

866 
	$X
(
E
)

867 
	$X
(
RgeE
)

868 
	$X
(
RenE
)

869 
	$X
(
SyaxE
)

870 
	$X
(
TyE
)

872 #unde
X


874 
le
 
	`ThrowE
(
v8
::
Lol
<v8::
Vue
> 
r
) {

875 
v8
::
Isީe
::
	`GCut
()->
	`ThrowExi
(
r
);

876 
	}
}

878 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
NewBufr
(

879 *
da


880 , 
size_t
 
ngth


881 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


882 , 
node
::
Bufr
::
FeClback
 
back


884 , 
node
::
smloc
::
FeClback
 
back


886 , *
ht


890 
as
(
ngth
 <
imp
::
kMaxLgth
 && "tooarge buffer");

891 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


892  
	gnode
::
Bufr
::
New
(

893 
v8
::
Isީe
::
GCut
(), 
da
, 
ngth
, 
back
, 
ht
);

895  
	gnode
::
Bufr
::
New
(
v8
::
Isީe
::
GCut
(), 
da
, 
ngth
, 
back
,

896 
ht
);

900 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$CyBufr
(

901 cڡ *
da


902 , 
ut32_t
 
size


906 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

907 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


908  
node
::
Bufr
::
	`Cy
(

909 
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

911  
node
::
Bufr
::
	`New
(
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

913 
	}
}

915 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(
ut32_t
 
size
) {

918 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

919 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


920  
node
::
Bufr
::
	`New
(

921 
v8
::
Isީe
::
	`GCut
(), 
size
);

923  
node
::
Bufr
::
	`New
(
v8
::
Isީe
::
	`GCut
(), 
size
);

925 
	}
}

927 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

928 * 
da


929 , 
ut32_t
 
size


933 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

934 #i
NODE_MODULE_VERSION
 > 
IOJS_2_0_MODULE_VERSION


935  
node
::
Bufr
::
	`New
(
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

937  
node
::
Bufr
::
	`U
(
v8
::
Isީe
::
	`GCut
(), 
da
, 
size
);

939 
	}
}

941 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

942 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

943 
le
 
MaybeLol
<
v8
::
Sg
>

944 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

945  
v8
::
Sg
::
NewFromOBy
(v8::
Isީe
::
GCut
(), 
vue
,

946 
v8
::
NewSgTy
::
kNm
, 
ngth
);

949 
le
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

950 
v8
::
Lol
<v8::
Sg
> 
s


951 , cڡ 
v8
::
StOrig
& 
ig


953 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

954 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

955 
	gv8
::
StComp
::
Sour
 
sour
(
s
, 
ig
);

956  
	gsce
.
Es
(

957 
v8
::
StComp
::
Compe
(
isީe
->
GCutCڋxt
(), &
sour
)

958 .
FromMaybe
(
v8
::
Lol
<
BoundSt
>()));

961 
le
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

962 
v8
::
Lol
<v8::
Sg
> 
s


964 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

965 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

966 
	gv8
::
StComp
::
Sour
 
sour
(
s
);

967  
	gsce
.
Es
(

968 
v8
::
StComp
::
Compe
(
isީe
->
GCutCڋxt
(), &
sour
)

969 .
FromMaybe
(
v8
::
Lol
<
BoundSt
>()));

972 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

973 
v8
::
Lol
<
UnboundSt
> 
st


975 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

976 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

977  
	gsce
.
Es
(
st
->
BdToCutCڋxt
()

978 ->
Run
(
isީe
->
GCutCڋxt
())

979 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

982 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

983 
v8
::
Lol
<
BoundSt
> 
st


985 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

986 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

987  
	gsce
.
Es
(
st
->
Run
(
isީe
->
GCutCڋxt
())

988 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

991 
le
 
	gMaybeLol
<
	gv8
::
Sg
>

992 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

993  
v8
::
Sg
::
NewFromOBy
(v8::
Isީe
::
GCut
(), 
vue
,

994 
v8
::
Sg
::
kNmSg
, 
ngth
);

997 
le
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

998 
v8
::
Lol
<v8::
Sg
> 
s


999 , cڡ 
v8
::
StOrig
& 
ig


1001 
v8
::
StComp
::
Sour
 
sour
(
s
, 
ig
);

1002  
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
sour
);

1005 
le
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

1006 
v8
::
Lol
<v8::
Sg
> 
s


1008 
v8
::
StComp
::
Sour
 
sour
(
s
);

1009  
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
sour
);

1012 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

1013 
v8
::
Lol
<
UnboundSt
> 
st


1015 
EsbHdSce
 
sce
;

1016  
	gsce
.
Es
(
st
->
BdToCutCڋxt
()->
Run
());

1019 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(

1020 
v8
::
Lol
<
BoundSt
> 
st


1022  
st
->
Run
();

1026 
NAN_DEPRECATED
 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1027 
v8
::
Lol
<v8::
Obje
> 
rg


1028 , 
v8
::
Lol
<v8::
Funi
> 
func


1029 , 
gc


1030 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1031 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


1032 
EsbHdSce
 
sce
;

1033  
	gsce
.
Es
(
New
(
node
::
MakeClback
(

1034 
v8
::
Isީe
::
GCut
(), 
rg
, 
func
, 
gc
, 
gv
)));

1036 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1037 
AsyncResour
 
s
("nan:makeCallback");

1038  
	gs
.
runInAsyncSce
(
rg
, 
func
, 
gc
, 
gv
)

1039 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

1041  
	gnode
::
MakeClback
(

1042 
v8
::
Isީe
::
GCut
(), 
rg
, 
func
, 
gc
, 
gv
);

1047 
NAN_DEPRECATED
 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1048 
v8
::
Lol
<v8::
Obje
> 
rg


1049 , 
v8
::
Lol
<v8::
Sg
> 
symb


1050 , 
gc


1051 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1052 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


1053 
EsbHdSce
 
sce
;

1054  
	gsce
.
Es
(
New
(
node
::
MakeClback
(

1055 
v8
::
Isީe
::
GCut
(), 
rg
, 
symb
, 
gc
, 
gv
)));

1057 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1058 
AsyncResour
 
s
("nan:makeCallback");

1059  
	gs
.
runInAsyncSce
(
rg
, 
symb
, 
gc
, 
gv
)

1060 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

1062  
	gnode
::
MakeClback
(

1063 
v8
::
Isީe
::
GCut
(), 
rg
, 
symb
, 
gc
, 
gv
);

1068 
NAN_DEPRECATED
 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1069 
v8
::
Lol
<v8::
Obje
> 
rg


1070 , cڡ * 
mhod


1071 , 
gc


1072 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1073 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


1074 
EsbHdSce
 
sce
;

1075  
	gsce
.
Es
(
New
(
node
::
MakeClback
(

1076 
v8
::
Isީe
::
GCut
(), 
rg
, 
mhod
, 
gc
, 
gv
)));

1078 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1079 
AsyncResour
 
s
("nan:makeCallback");

1080  
	gs
.
runInAsyncSce
(
rg
, 
mhod
, 
gc
, 
gv
)

1081 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

1083  
	gnode
::
MakeClback
(

1084 
v8
::
Isީe
::
GCut
(), 
rg
, 
mhod
, 
gc
, 
gv
);

1089 
le
 
	$FExi
(cڡ 
TryCch
& 
y_tch
) {

1090 
node
::
	`FExi
(
v8
::
Isީe
::
	`GCut
(), 
y_tch
.
y_tch_
);

1091 
	}
}

1093 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$EnoExi
(

1094 
rno


1095 , cڡ * 
sys
 = 
NULL


1096 , cڡ * 
mesge
 = 
NULL


1097 , cڡ * 
th
 = 
NULL
) {

1098  
node
::
	`EnoExi
(
v8
::
Isީe
::
	`GCut
(), 
rno
, 
sys
,

1099 
mesge
, 
th
);

1100 
	}
}

1102 
NAN_DEPRECATED
 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$NEnoExi
(

1103 
rno


1104 , cڡ * 
sys
 = 
NULL


1105 , cڡ * 
mesge
 = 
NULL


1106 , cڡ * 
th
 = 
NULL
) {

1107  
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

1108 
	}
}

1110 
	gme
<
tyme
 
	gT
>

1111 
le
 
	$SIsީeDa
(

1112 
v8
::
Isީe
 *
isީe


1113 , 
T
 *
da


1115 
isީe
->
	`SDa
(0, 
da
);

1116 
	}
}

1118 
	gme
<
tyme
 
	gT
>

1119 
le
 
T
 *
	$GIsީeDa
(

1120 
v8
::
Isީe
 *
isީe


1122  
ic_
<
T
*>(
isީe
->
	`GDa
(0));

1123 
	}
}

1125 as
	cUtf8Sg
 {

1126 
	gpublic
:

1127 
le
 
exic
 
Utf8Sg
(
v8
::
Lol
<v8::
Vue
> 
om
) :

1128 
ngth_
(0), 
r_
(
r__
) {

1129 
HdSce
 
	gsce
;

1130 i(!
	gom
.
IsEmy
()) {

1131 #i
NODE_MAJOR_VERSION
 >= 10

1132 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
cڋxt
 = 
GCutCڋxt
();

1133 
	gv8
::
Lol
<
v8
::
Sg
> 
rg
 =

1134 
om
->
ToSg
(
cڋxt
).
FromMaybe
(
v8
::
Lol
<v8::
Sg
>());

1136 
	gv8
::
Lol
<
v8
::
Sg
> 
rg
 = 
om
->
ToSg
();

1138 i(!
	grg
.
IsEmy
()) {

1139 
size_t
 
	gn
 = 3 * 
rg
->
Lgth
() + 1;

1140 
as
(
n
 <
INT_MAX
);

1141 i(
	gn
 >  (
	gr__
)) {

1142 
	gr_
 = 
ic_
<*>(
mloc
(
n
));

1143 
as
(
r_
 != 0);

1145 cڡ 
	gags
 =

1146 
v8
::
Sg
::
NO_NULL_TERMINATION
 | 
imp
::
kRInvidUtf8
;

1147 #i
NODE_MAJOR_VERSION
 >= 11

1148 
	gngth_
 = 
rg
->
WreUtf8
(
v8
::
Isީe
::
GCut
(), 
r_
,

1149 
ic_
<>(
n
), 0, 
ags
);

1153 #ifde
_MSC_VER


1154 #agm
wng
(
push
)

1155 #agm
wng
(
dib
 : 4996)

1157 #ifde
__GNUC__


1158 #agm
GCC
 
dgnoic
 
push


1159 #agm
GCC
 
dgnoic
 
igned
 "-Wdeprecated-declarations"

1161 
	gngth_
 = 
rg
->
WreUtf8
(
r_
, 
ic_
<>(
n
), 0, 
ags
);

1162 #ifde
__GNUC__


1163 #agm
GCC
 
dgnoic
 
p


1165 #ifde
_MSC_VER


1166 #agm
wng
(
p
)

1169 
	gr_
[
ngth_
] = '\0';

1174 
le
 
ngth
() const {

1175  
	gngth_
;

1178 
le
 * 
	gݔ
*({  
	gr_
; }

1179 
le
 cڡ * 
	gݔ
*(cڡ {  
	gr_
; }

1181 
	gle
 ~
Utf8Sg
() {

1182 i(
	gr_
 !
r__
) {

1183 

(
r_
);

1187 
	give
:

1188 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Utf8Sg
)

1190 
ngth_
;

1191 *
	gr_
;

1192 
	gr__
[1024];

1196 
le
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Undefed
() {

1197 
EsbHdSce
 
sce
;

1198  
sce
.
	`Es
(
	`New
(
v8
::
	`Undefed
()));

1199 
	}
}

1201 
le
 
	gv8
::
Lol
<
v8
::
Primive
> 
	$Nu
() {

1202 
EsbHdSce
 
sce
;

1203  
sce
.
	`Es
(
	`New
(
v8
::
	`Nu
()));

1204 
	}
}

1206 
le
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$True
() {

1207 
EsbHdSce
 
sce
;

1208  
sce
.
	`Es
(
	`New
(
v8
::
	`True
()));

1209 
	}
}

1211 
le
 
	gv8
::
Lol
<
v8
::
Boޗn
> 
	$F
() {

1212 
EsbHdSce
 
sce
;

1213  
sce
.
	`Es
(
	`New
(
v8
::
	`F
()));

1214 
	}
}

1216 
le
 
	gv8
::
Lol
<
v8
::
Sg
> 
	$EmySg
() {

1217  
v8
::
Sg
::
	`Emy
();

1218 
	}
}

1220 
le
 
	$AdjuExMemy
(
bc
) {

1221  
ic_
<>(
v8
::
V8
::
	`AdjuAmouOfExAodMemy
(
bc
));

1222 
	}
}

1224 
le
 
STeme
(

1225 
v8
::
Lol
<v8::
Teme
> 
m


1226 , cڡ *
me


1227 , 
v8
::
Lol
<v8::
Da
> 
vue
) {

1228 
m
->
S
(
me
, 
vue
);

1231 
le
 
STeme
(

1232 
v8
::
Lol
<v8::
Teme
> 
m


1233 , 
v8
::
Lol
<v8::
Sg
> 
me


1234 , 
v8
::
Lol
<v8::
Da
> 
vue


1235 , 
v8
::
PrݔtyAribu
 
ibus
) {

1236 
m
->
S
(
me
, 
vue
, 
ibus
);

1239 
le
 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
	$GCutCڋxt
() {

1240  
v8
::
Cڋxt
::
	`GCut
();

1241 
	}
}

1243 
le
 * 
GIlFldPor
(

1244 
v8
::
Lol
<v8::
Obje
> 
obje


1245 , 
dex
) {

1246  
	gobje
->
GPorFromIlFld
(
dex
);

1249 
le
 
SIlFldPor
(

1250 
v8
::
Lol
<v8::
Obje
> 
obje


1251 , 
dex


1252 , * 
vue
) {

1253 
	gobje
->
SPorInIlFld
(
dex
, 
vue
);

1256 
	#NAN_GC_CALLBACK
(
me
) \

1257 
	$me
(
v8
::
GCTy
 
ty
, v8::
GCClbackFgs
 
ags
)

	)

1259 
le
 
	$AddGCEpogueClback
(

1260 
v8
::
GCEpogueClback
 
back


1261 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

1262 
v8
::
V8
::
	`AddGCEpogueClback
(
back
, 
gc_ty_fr
);

1263 
	}
}

1264 
le
 
	$RemoveGCEpogueClback
(

1265 
v8
::
GCEpogueClback
 
back
) {

1266 
v8
::
V8
::
	`RemoveGCEpogueClback
(
back
);

1267 
	}
}

1268 
le
 
	$AddGCProgueClback
(

1269 
v8
::
GCProgueClback
 
back


1270 , 
v8
::
GCTy
 
gc_ty_fr
 = v8::
kGCTyA
) {

1271 
v8
::
V8
::
	`AddGCProgueClback
(
back
, 
gc_ty_fr
);

1272 
	}
}

1273 
le
 
	$RemoveGCProgueClback
(

1274 
v8
::
GCProgueClback
 
back
) {

1275 
v8
::
V8
::
	`RemoveGCProgueClback
(
back
);

1276 
	}
}

1277 
le
 
	$GHpStiics
(

1278 
v8
::
HpStiics
 *
hp_iics
) {

1279 
v8
::
V8
::
	`GHpStiics
(
hp_iics
);

1280 
	}
}

1282 
	#X
(
NAME
) \

1283 
le
 
v8
::
Lol
<v8::
Vue
> 
	$NAME
(cڡ *
msg
) { \

1284 
EsbHdSce
 
sce
; \

1285  
sce
.
	`Es
(
v8
::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

1286 
	}
} \

1288 
le
 \

1289 
v8
::
Lol
<v8::
Vue
> 
	`NAME
(v8::Lol<v8::
Sg
> 
msg
) { \

1290  
v8
::
Exi
::
	`NAME
(
msg
); \

1293 
le
 
Throw
 ## 
	$NAME
(cڡ *
msg
) { \

1294 
HdSce
 
sce
; \

1295 
v8
::
	`ThrowExi
(v8::
Exi
::
	`NAME
(
	`New
(
msg
).
	`ToLolChecked
())); \

1296 
	}
} \

1298 
le
 \

1299 
Throw
 ## 
	`NAME
(
v8
::
Lol
<v8::
Sg
> 
rmsg
) { \

1300 
HdSce
 
sce
; \

1301 
v8
::
	`ThrowExi
(v8::
Exi
::
	`NAME
(
rmsg
)); \

1302 }

	)

1304 
	$X
(
E
)

1305 
	$X
(
RgeE
)

1306 
	$X
(
RenE
)

1307 
	$X
(
SyaxE
)

1308 
	$X
(
TyE
)

1310 #unde
X


1312 
le
 
	`ThrowE
(
v8
::
Lol
<v8::
Vue
> 
r
) {

1313 
v8
::
	`ThrowExi
(
r
);

1314 
	}
}

1316 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

1317 *
da


1318 , 
size_t
 
ngth


1319 , 
node
::
Bufr
::
_back
 
back


1320 , *
ht


1322 
EsbHdSce
 
sce
;

1325 
	`as
(
ngth
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1326  
sce
.
	`Es
(

1327 
	`New
(
node
::
Bufr
::New(
da
, 
ngth
, 
back
, 
ht
)->
hd_
));

1328 
	}
}

1330 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$CyBufr
(

1331 cڡ *
da


1332 , 
ut32_t
 
size


1334 
EsbHdSce
 
sce
;

1337 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1338 #i
NODE_MODULE_VERSION
 >
NODE_0_10_MODULE_VERSION


1339  
sce
.
	`Es
(
	`New
(
node
::
Bufr
::New(
da
, 
size
)->
hd_
));

1341  
sce
.
	`Es
(

1342 
	`New
(
node
::
Bufr
::New(
cڡ_
<*>(
da
), 
size
)->
hd_
));

1344 
	}
}

1346 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(
ut32_t
 
size
) {

1349 
EsbHdSce
 
sce
;

1350 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1351  
sce
.
	`Es
(
	`New
(
node
::
Bufr
::New(
size
)->
hd_
));

1352 
	}
}

1354 
le
 
	$FeDa
(*
da
, *
ht
) {

1355 (
ht
;

1356 
de
[] 
da
;

1357 
	}
}

1359 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
	$NewBufr
(

1360 * 
da


1361 , 
ut32_t
 
size


1363 
EsbHdSce
 
sce
;

1366 
	`as
(
size
 <
imp
::
kMaxLgth
 && "tooarge buffer");

1367  
sce
.
	`Es
(

1368 
	`New
(
node
::
Bufr
::New(
da
, 
size
, 
FeDa
, 
NULL
)->
hd_
));

1369 
	}
}

1371 
mea
 
	gimp
 {

1372 
le
 

1373 
widSg
(
d
::
ve
<
ut16_t
> *
ws
, cڡ 
ut8_t
 *
s
, 
l
) {

1374 
size_t
 
	gn
 = 
ic_
<size_t>(
l
);

1375 i(
	gl
 < 0) {

1376 
	gn
 = 

(
t_
<cڡ *>(
s
));

1378 
as
(
n
 <
INT_MAX
 && "stringooong");

1379 
	gws
->
size
(
n
);

1380 
	gd
::
cy
(
s
, s + 
n
, 
ws
->
beg
());

1384 
le
 
	gMaybeLol
<
	gv8
::
Sg
>

1385 
NewOBySg
(cڡ 
ut8_t
 * 
vue
, 
ngth
 = -1) {

1386 
d
::
ve
<
ut16_t
> 
wideSg
;

1387 
	gimp
::
widSg
(&
wideSg
, 
vue
, 
ngth
);

1388  
	gv8
::
Sg
::
New
(
wideSg
.
da
(),

1389 
ic_
<>(
wideSg
.
size
()));

1392 
le
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

1393 
v8
::
Lol
<v8::
Sg
> 
s


1394 , cڡ 
v8
::
StOrig
& 
ig


1396  
v8
::
St
::
Compe
(
s
, 
cڡ_
<v8::
StOrig
 *>(&
ig
));

1399 
le
 
	gMaybeLol
<
	gBoundSt
> 
CompeSt
(

1400 
v8
::
Lol
<v8::
Sg
> 
s


1402  
v8
::
St
::
Compe
(
s
);

1405 
le


1406 
	gMaybeLol
<
	gv8
::
Vue
> 
RunSt
(
v8
::
Lol
<v8::
St
> 
st
) {

1407  
st
->
Run
();

1410 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1411 
v8
::
Lol
<v8::
Obje
> 
rg


1412 , 
v8
::
Lol
<v8::
Funi
> 
func


1413 , 
gc


1414 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1415 
v8
::
HdSce
 
sce
;

1416  
	gsce
.
Clo
(
New
(
node
::
MakeClback
(
rg
, 
func
, 
gc
, 
gv
)));

1419 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1420 
v8
::
Lol
<v8::
Obje
> 
rg


1421 , 
v8
::
Lol
<v8::
Sg
> 
symb


1422 , 
gc


1423 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1424 
v8
::
HdSce
 
sce
;

1425  
	gsce
.
Clo
(
New
(
node
::
MakeClback
(
rg
, 
symb
, 
gc
, 
gv
)));

1428 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
MakeClback
(

1429 
v8
::
Lol
<v8::
Obje
> 
rg


1430 , cڡ * 
mhod


1431 , 
gc


1432 , 
v8
::
Lol
<v8::
Vue
>* 
gv
) {

1433 
v8
::
HdSce
 
sce
;

1434  
	gsce
.
Clo
(
New
(
node
::
MakeClback
(
rg
, 
mhod
, 
gc
, 
gv
)));

1437 
le
 
	$FExi
(cڡ 
TryCch
& 
y_tch
) {

1438 
node
::
	`FExi
(
cڡ_
<
v8
::
TryCch
 &>(
y_tch
.
y_tch_
));

1439 
	}
}

1441 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$EnoExi
(

1442 
rno


1443 , cڡ * 
sys
 = 
NULL


1444 , cڡ * 
mesge
 = 
NULL


1445 , cڡ * 
th
 = 
NULL
) {

1446  
node
::
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

1447 
	}
}

1449 
NAN_DEPRECATED
 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$NEnoExi
(

1450 
rno


1451 , cڡ * 
sys
 = 
NULL


1452 , cڡ * 
mesge
 = 
NULL


1453 , cڡ * 
th
 = 
NULL
) {

1454  
	`EnoExi
(
rno
, 
sys
, 
mesge
, 
th
);

1455 
	}
}

1458 
	gme
<
tyme
 
	gT
>

1459 
le
 
	$SIsީeDa
(

1460 
v8
::
Isީe
 *
isީe


1461 , 
T
 *
da


1463 
isީe
->
	`SDa
(
da
);

1464 
	}
}

1466 
	gme
<
tyme
 
	gT
>

1467 
le
 
T
 *
	$GIsީeDa
(

1468 
v8
::
Isީe
 *
isީe


1470  
ic_
<
T
*>(
isީe
->
	`GDa
());

1471 
	}
}

1473 as
	cUtf8Sg
 {

1474 
	gpublic
:

1475 
le
 
exic
 
Utf8Sg
(
v8
::
Lol
<v8::
Vue
> 
om
) :

1476 
ngth_
(0), 
r_
(
r__
) {

1477 
	gv8
::
HdSce
 
sce
;

1478 i(!
	gom
.
IsEmy
()) {

1479 
	gv8
::
Lol
<
v8
::
Sg
> 
rg
 = 
om
->
ToSg
();

1480 i(!
	grg
.
IsEmy
()) {

1481 
size_t
 
	gn
 = 3 * 
rg
->
Lgth
() + 1;

1482 
as
(
n
 <
INT_MAX
);

1483 i(
	gn
 >  (
	gr__
)) {

1484 
	gr_
 = 
ic_
<*>(
mloc
(
n
));

1485 
as
(
r_
 != 0);

1487 cڡ 
	gags
 =

1488 
v8
::
Sg
::
NO_NULL_TERMINATION
 | 
imp
::
kRInvidUtf8
;

1489 
	gngth_
 = 
rg
->
WreUtf8
(
r_
, 
ic_
<>(
n
), 0, 
ags
);

1490 
	gr_
[
ngth_
] = '\0';

1495 
le
 
ngth
() const {

1496  
	gngth_
;

1499 
le
 * 
	gݔ
*({  
	gr_
; }

1500 
le
 cڡ * 
	gݔ
*(cڡ {  
	gr_
; }

1502 
	gle
 ~
Utf8Sg
() {

1503 i(
	gr_
 !
r__
) {

1504 

(
r_
);

1508 
	give
:

1509 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Utf8Sg
)

1511 
ngth_
;

1512 *
	gr_
;

1513 
	gr__
[1024];

1518 (*
	tFeClback
)(*
	tda
, *
	tht
);

1520 cڡ 
	tFuniClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_METHOD_ARGS_TYPE
;

1521 
	tNAN_METHOD_RETURN_TYPE
;

1523 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_GETTER_ARGS_TYPE
;

1524 
	tNAN_GETTER_RETURN_TYPE
;

1526 cڡ 
	tPrݔtyClbackInfo
<>& 
	tNAN_SETTER_ARGS_TYPE
;

1527 
	tNAN_SETTER_RETURN_TYPE
;

1529 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&

1530 
	tNAN_PROPERTY_GETTER_ARGS_TYPE
;

1531 
	tNAN_PROPERTY_GETTER_RETURN_TYPE
;

1533 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&

1534 
	tNAN_PROPERTY_SETTER_ARGS_TYPE
;

1535 
	tNAN_PROPERTY_SETTER_RETURN_TYPE
;

1537 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&

1538 
	tNAN_PROPERTY_ENUMERATOR_ARGS_TYPE
;

1539 
	tNAN_PROPERTY_ENUMERATOR_RETURN_TYPE
;

1541 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&

1542 
	tNAN_PROPERTY_DELETER_ARGS_TYPE
;

1543 
	tNAN_PROPERTY_DELETER_RETURN_TYPE
;

1545 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&

1546 
	tNAN_PROPERTY_QUERY_ARGS_TYPE
;

1547 
	tNAN_PROPERTY_QUERY_RETURN_TYPE
;

1549 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_INDEX_GETTER_ARGS_TYPE
;

1550 
	tNAN_INDEX_GETTER_RETURN_TYPE
;

1552 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>& 
	tNAN_INDEX_SETTER_ARGS_TYPE
;

1553 
	tNAN_INDEX_SETTER_RETURN_TYPE
;

1555 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&

1556 
	tNAN_INDEX_ENUMERATOR_ARGS_TYPE
;

1557 
	tNAN_INDEX_ENUMERATOR_RETURN_TYPE
;

1559 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&

1560 
	tNAN_INDEX_DELETER_ARGS_TYPE
;

1561 
	tNAN_INDEX_DELETER_RETURN_TYPE
;

1563 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&

1564 
	tNAN_INDEX_QUERY_ARGS_TYPE
;

1565 
	tNAN_INDEX_QUERY_RETURN_TYPE
;

1567 
	#NAN_METHOD
(
me
) \

1568 
N
::
NAN_METHOD_RETURN_TYPE
 
	$me
(
N
::
NAN_METHOD_ARGS_TYPE
 
fo
)

	)

1569 
	#NAN_GETTER
(
me
) \

1570 
N
::
NAN_GETTER_RETURN_TYPE
 
	`me
( \

1571 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1572 , 
N
::
NAN_GETTER_ARGS_TYPE
 
fo
)

	)

1573 
	#NAN_SETTER
(
me
) \

1574 
N
::
NAN_SETTER_RETURN_TYPE
 
	`me
( \

1575 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1576 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1577 , 
N
::
NAN_SETTER_ARGS_TYPE
 
fo
)

	)

1578 
	#NAN_PROPERTY_GETTER
(
me
) \

1579 
N
::
NAN_PROPERTY_GETTER_RETURN_TYPE
 
	`me
( \

1580 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1581 , 
N
::
NAN_PROPERTY_GETTER_ARGS_TYPE
 
fo
)

	)

1582 
	#NAN_PROPERTY_SETTER
(
me
) \

1583 
N
::
NAN_PROPERTY_SETTER_RETURN_TYPE
 
	`me
( \

1584 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1585 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1586 , 
N
::
NAN_PROPERTY_SETTER_ARGS_TYPE
 
fo
)

	)

1587 
	#NAN_PROPERTY_ENUMERATOR
(
me
) \

1588 
N
::
NAN_PROPERTY_ENUMERATOR_RETURN_TYPE
 
	`me
( \

1589 
N
::
NAN_PROPERTY_ENUMERATOR_ARGS_TYPE
 
fo
)

	)

1590 
	#NAN_PROPERTY_DELETER
(
me
) \

1591 
N
::
NAN_PROPERTY_DELETER_RETURN_TYPE
 
	`me
( \

1592 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1593 , 
N
::
NAN_PROPERTY_DELETER_ARGS_TYPE
 
fo
)

	)

1594 
	#NAN_PROPERTY_QUERY
(
me
) \

1595 
N
::
NAN_PROPERTY_QUERY_RETURN_TYPE
 
	`me
( \

1596 
v8
::
Lol
<v8::
Sg
> 
ݔty
 \

1597 , 
N
::
NAN_PROPERTY_QUERY_ARGS_TYPE
 
fo
)

	)

1598 
	#NAN_INDEX_GETTER
(
me
) \

1599 
N
::
NAN_INDEX_GETTER_RETURN_TYPE
 
	`me
( \

1600 
ut32_t
 
dex
 \

1601 , 
N
::
NAN_INDEX_GETTER_ARGS_TYPE
 
fo
)

	)

1602 
	#NAN_INDEX_SETTER
(
me
) \

1603 
N
::
NAN_INDEX_SETTER_RETURN_TYPE
 
	`me
( \

1604 
ut32_t
 
dex
 \

1605 , 
v8
::
Lol
<v8::
Vue
> 
vue
 \

1606 , 
N
::
NAN_INDEX_SETTER_ARGS_TYPE
 
fo
)

	)

1607 
	#NAN_INDEX_ENUMERATOR
(
me
) \

1608 
N
::
NAN_INDEX_ENUMERATOR_RETURN_TYPE
 \

1609 
	$me
(
N
::
NAN_INDEX_ENUMERATOR_ARGS_TYPE
 
fo
)

	)

1610 
	#NAN_INDEX_DELETER
(
me
) \

1611 
N
::
NAN_INDEX_DELETER_RETURN_TYPE
 
	`me
( \

1612 
ut32_t
 
dex
 \

1613 , 
N
::
NAN_INDEX_DELETER_ARGS_TYPE
 
fo
)

	)

1614 
	#NAN_INDEX_QUERY
(
me
) \

1615 
N
::
NAN_INDEX_QUERY_RETURN_TYPE
 
	`me
( \

1616 
ut32_t
 
dex
 \

1617 , 
N
::
NAN_INDEX_QUERY_ARGS_TYPE
 
fo
)

	)

1619 as
	cClback
 {

1620 
public
:

1621 
	`Clback
() {}

1623 
exic
 
	`Clback
(cڡ 
v8
::
Lol
<v8::
Funi
> &

: 
	`hd_
(fn) {}

1625 ~
	`Clback
() {

1626 
hd_
.
	`Ret
();

1629 
bo
 
ݔ
==(cڡ 
Clback
 &
h
) const {

1630  
hd_
 =
h
.handle_;

1633 
bo
 
ݔ
!=(cڡ 
Clback
 &
h
) const {

1634  !
ݔ
==(
h
);

1637 
le


1638 
v8
::
Lol
<v8::
Funi
> 
ݔ
*(cڡ {  
	`GFuni
(); }

1640 
NAN_DEPRECATED
 
le
 
v8
::
Lol
<v8::
Vue
> 
	`ݔ
()(

1641 
v8
::
Lol
<v8::
Obje
> 
rg


1642 , 
gc
 = 0

1643 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1644 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1645 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1646 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1647 
AsyncResour
 
	`async
("nan:Callback:operator()");

1648  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
, &
async
)

1649 .
	`FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

1651  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
);

1654  
	`Cl_
(
rg
, 
gc
, 
gv
);

1658 
NAN_DEPRECATED
 
le
 
v8
::
Lol
<v8::
Vue
> 
	`ݔ
()(

1659 
gc
 = 0

1660 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1661 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1662 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1663 
v8
::
EsbHdSce
 
	`sce
(
isީe
);

1664 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1665 
AsyncResour
 
	`async
("nan:Callback:operator()");

1666  
sce
.
	`Es
(
	`Cl_
(
isީe
, isީe->
	`GCutCڋxt
()->
	`Glob
(),

1667 
gc
, 
gv
, &
async
)

1668 .
	`FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1670  
sce
.
	`Es
(

1671 
	`Cl_
(
isީe
, isީe->
	`GCutCڋxt
()->
	`Glob
(), 
gc
, 
gv
));

1674 
v8
::
HdSce
 
sce
;

1675  
sce
.
	`Clo
(
	`Cl_
(
v8
::
Cڋxt
::
	`GCut
()->
	`Glob
(), 
gc
, 
gv
));

1679 
le
 
MaybeLol
<
v8
::
Vue
> 
	`ݔ
()(

1680 
AsyncResour
* 
sour


1681 , 
gc
 = 0

1682 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1683  
this
->
	`Cl
(
gc
, 
gv
, 
sour
);

1686 
le
 
MaybeLol
<
v8
::
Vue
> 
	`ݔ
()(

1687 
AsyncResour
* 
sour


1688 , 
v8
::
Lol
<v8::
Obje
> 
rg


1689 , 
gc
 = 0

1690 , 
v8
::
Lol
<v8::
Vue
> 
gv
[] = 0) const {

1691  
this
->
	`Cl
(
rg
, 
gc
, 
gv
, 
sour
);

1695 
le
 
	`SFuni
(cڡ 
v8
::
Lol
<v8::
Funi
> &

) {

1696 
	`Ret
(

);

1699 
le
 
	`Ret
(cڡ 
v8
::
Lol
<v8::
Funi
> &

) {

1700 
hd_
.
	`Ret
(

);

1703 
le
 
	`Ret
() {

1704 
hd_
.
	`Ret
();

1707 
le
 
v8
::
Lol
<v8::
Funi
> 
	`GFuni
() const {

1708  
	`New
(
hd_
);

1711 
le
 
bo
 
	`IsEmy
() const {

1712  
hd_
.
	`IsEmy
();

1719 
NAN_DEPRECATED
 
le
 
v8
::
Lol
<v8::
Vue
>

1720 
	`Cl
(
v8
::
Lol
<v8::
Obje
> 
rg


1721 , 
gc


1722 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1723 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1724 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1725 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1726 
AsyncResour
 
	`async
("nan:Callback:Call");

1727  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
, &
async
)

1728 .
	`FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

1730  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
);

1733  
	`Cl_
(
rg
, 
gc
, 
gv
);

1741 
NAN_DEPRECATED
 
le
 
v8
::
Lol
<v8::
Vue
>

1742 
	`Cl
(
gc
, 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1743 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1744 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1745 
v8
::
EsbHdSce
 
	`sce
(
isީe
);

1746 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1747 
AsyncResour
 
	`async
("nan:Callback:Call");

1748  
sce
.
	`Es
(
	`Cl_
(
isީe
, isީe->
	`GCutCڋxt
()->
	`Glob
(),

1749 
gc
, 
gv
, &
async
)

1750 .
	`FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1752  
sce
.
	`Es
(

1753 
	`Cl_
(
isީe
, isީe->
	`GCutCڋxt
()->
	`Glob
(), 
gc
, 
gv
));

1756 
v8
::
HdSce
 
sce
;

1757  
sce
.
	`Clo
(
	`Cl_
(
v8
::
Cڋxt
::
	`GCut
()->
	`Glob
(), 
gc
, 
gv
));

1761 
le
 
MaybeLol
<
v8
::
Vue
>

1762 
	`Cl
(
v8
::
Lol
<v8::
Obje
> 
rg


1763 , 
gc


1764 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]

1765 , 
AsyncResour
* 
sour
) const {

1766 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1767 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
	`GCut
();

1768  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
, 
sour
);

1769 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1770 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1771  
	`Cl_
(
isީe
, 
rg
, 
gc
, 
gv
);

1773  
	`Cl_
(
rg
, 
gc
, 
gv
);

1777 
le
 
MaybeLol
<
v8
::
Vue
>

1778 
	`Cl
(
gc
, 
v8
::
Lol
<v8::
Vue
> 
gv
[], 
AsyncResour
* 
sour
) const {

1779 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1780 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
	`GCut
();

1781  
	`Cl
(
isީe
->
	`GCutCڋxt
()->
	`Glob
(), 
gc
, 
gv
, 
sour
);

1782 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1783 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
();

1784 
v8
::
EsbHdSce
 
	`sce
(
isީe
);

1785  
sce
.
	`Es
(

1786 
	`Cl_
(
isީe
, isީe->
	`GCutCڋxt
()->
	`Glob
(), 
gc
, 
gv
));

1788 
v8
::
HdSce
 
sce
;

1789  
sce
.
	`Clo
(
	`Cl_
(
v8
::
Cڋxt
::
	`GCut
()->
	`Glob
(), 
gc
, 
gv
));

1793 
ive
:

1794 
	`NAN_DISALLOW_ASSIGN_COPY_MOVE
(
Clback
)

1795 
Psit
<
v8
::
Funi
> 
hd_
;

1797 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


1798 
MaybeLol
<
v8
::
Vue
> 
	`Cl_
(v8::
Isީe
 *
isީe


1799 , 
v8
::
Lol
<v8::
Obje
> 
rg


1800 , 
gc


1801 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]

1802 , 
AsyncResour
* 
sour
) const {

1803 
EsbHdSce
 
sce
;

1804 
v8
::
Lol
<v8::
Funi
> 
func
 = 
	`New
(
hd_
);

1805 aut
maybe
 = 
sour
->
	`runInAsyncSce
(
rg
, 
func
, 
gc
, 
gv
);

1806 
v8
::
Lol
<v8::
Vue
> 
lol
;

1807 i(!
maybe
.
	`ToLol
(&
lol
) 
MaybeLol
<
v8
::
Vue
>();

1808  
sce
.
	`Es
(
lol
);

1810 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1811 
v8
::
Lol
<v8::
Vue
> 
	`Cl_
(v8::
Isީe
 *
isީe


1812 , 
v8
::
Lol
<v8::
Obje
> 
rg


1813 , 
gc


1814 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1815 
EsbHdSce
 
sce
;

1817 
v8
::
Lol
<v8::
Funi
> 
back
 = 
	`New
(
hd_
);

1818 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


1819  
sce
.
	`Es
(
	`New
(
node
::
	`MakeClback
(

1820 
isީe


1821 , 
rg


1822 , 
back


1823 , 
gc


1824 , 
gv


1827  
sce
.
	`Es
(
node
::
	`MakeClback
(

1828 
isީe


1829 , 
rg


1830 , 
back


1831 , 
gc


1832 , 
gv


1837 
v8
::
Lol
<v8::
Vue
> 
	`Cl_
(v8::Lol<v8::
Obje
> 
rg


1838 , 
gc


1839 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) const {

1840 
EsbHdSce
 
sce
;

1842 
v8
::
Lol
<v8::
Funi
> 
back
 = 
	`New
(
hd_
);

1843  
sce
.
	`Es
(
	`New
(
node
::
	`MakeClback
(

1844 
rg


1845 , 
back


1846 , 
gc


1847 , 
gv


1851 
	}
};

1853 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

1854 cڡ 
N
::
Clback
& 
back


1855 , 
v8
::
Lol
<v8::
Obje
> 
cv


1856 , 
gc


1857 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

1858  
Cl
(*
back
, 
cv
, 
gc
, 
gv
);

1861 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

1862 cڡ 
N
::
Clback
& 
back


1863 , 
gc


1864 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

1865 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


1866 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
GCut
();

1867 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

1868  
	gsce
.
Es
(

1869 
Cl
(*
back
, 
isީe
->
GCutCڋxt
()->
Glob
(), 
gc
, 
gv
)

1870 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1872 
EsbHdSce
 
	gsce
;

1873  
	gsce
.
Es
(

1874 
Cl
(*
back
, 
v8
::
Cڋxt
::
GCut
()->
Glob
(), 
gc
, 
gv
)

1875 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1879 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

1880 
v8
::
Lol
<v8::
Sg
> 
symb


1881 , 
v8
::
Lol
<v8::
Obje
> 
cv


1882 , 
gc


1883 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

1884 
EsbHdSce
 
sce
;

1885 
	gv8
::
Lol
<
v8
::
Vue
> 
_v
 =

1886 
G
(
cv
, 
symb
).
FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

1887 i(
	g_v
.
IsEmy
(|| !_v->
IsFuni
() 
	gv8
::
Lol
<
v8
::
Vue
>();

1888 
	gv8
::
Lol
<
v8
::
Funi
> 

 = 
_v
.
As
<v8::Function>();

1889  
	gsce
.
Es
(

1890 
Cl
(

, 
cv
, 
gc
, 
gv
).
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1893 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

1894 cڡ * 
mhod


1895 , 
v8
::
Lol
<v8::
Obje
> 
cv


1896 , 
gc


1897 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

1898 
EsbHdSce
 
sce
;

1899 
	gv8
::
Lol
<
v8
::
Sg
> 
mhod_rg
 =

1900 
New
<
v8
::
Sg
>(
mhod
).
ToLolChecked
();

1901  
	gsce
.
Es
(

1902 
Cl
(
mhod_rg
, 
cv
, 
gc
, 
gv
).
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1905  cs
	cAsyncWk
 {

1906 
	gpublic
:

1907 
exic
 
AsyncWk
(
Clback
 *
back_
,

1908 cڡ * 
sour_me
 = "nan:AsyncWorker")

1909 : 
back
(
back_
), 
rmsg_
(
NULL
) {

1910 
	gque
.
	gda
 = 
this
;

1912 
HdSce
 
	gsce
;

1913 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
New
<v8::Object>();

1914 
	grsitHd
.
Ret
(
obj
);

1915 
	gasync_sour
 = 
w
 
AsyncResour
(
sour_me
, 
obj
);

1918 
	gvtu
 ~
AsyncWk
() {

1919 
HdSce
 
	gsce
;

1921 i(!
	grsitHd
.
IsEmy
())

1922 
	grsitHd
.
Ret
();

1923 
de
 
	gback
;

1924 
	gde
[] 
	grmsg_
;

1925 
de
 
	gasync_sour
;

1928 
vtu
 
WkCome
() {

1929 
HdSce
 
	gsce
;

1931 i(
	grmsg_
 =
NULL
)

1932 
HdOKClback
();

1934 
HdEClback
();

1935 
de
 
	gback
;

1936 
	gback
 = 
NULL
;

1939 
le
 
SaveToPsit
(

1940 cڡ *
key
, cڡ 
v8
::
Lol
<v8::
Vue
> &
vue
) {

1941 
HdSce
 
sce
;

1942 
S
(
New
(
rsitHd
), New(
key
).
ToLolChecked
(), 
vue
).
FromJu
();

1945 
le
 
SaveToPsit
(

1946 cڡ 
v8
::
Lol
<v8::
Sg
> &
key
, cڡ v8::Lol<v8::
Vue
> &
vue
) {

1947 
HdSce
 
sce
;

1948 
S
(
New
(
rsitHd
), 
key
, 
vue
).
FromJu
();

1951 
le
 
SaveToPsit
(

1952 
ut32_t
 
dex
, cڡ 
v8
::
Lol
<v8::
Vue
> &
vue
) {

1953 
HdSce
 
sce
;

1954 
S
(
New
(
rsitHd
), 
dex
, 
vue
).
FromJu
();

1957 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
GFromPsit
(cڡ *
key
) const {

1958 
EsbHdSce
 
sce
;

1959  
	gsce
.
Es
(

1960 
G
(
New
(
rsitHd
), New(
key
).
ToLolChecked
())

1961 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1964 
le
 
	gv8
::
Lol
<
v8
::
Vue
>

1965 
GFromPsit
(cڡ 
v8
::
Lol
<v8::
Sg
> &
key
) const {

1966 
EsbHdSce
 
sce
;

1967  
	gsce
.
Es
(

1968 
G
(
New
(
rsitHd
), 
key
)

1969 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1972 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
GFromPsit
(
ut32_t
 
dex
) const {

1973 
EsbHdSce
 
sce
;

1974  
	gsce
.
Es
(

1975 
G
(
New
(
rsitHd
), 
dex
)

1976 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

1979 
vtu
 
Execu
() = 0;

1981 
uv_wk_t
 
	gque
;

1983 
vtu
 
Deroy
() {

1984 
de
 
	gthis
;

1987 
	geed
:

1988 
Psit
<
v8
::
Obje
> 
rsitHd
;

1989 
Clback
 *
	gback
;

1990 
AsyncResour
 *
	gasync_sour
;

1992 
vtu
 
HdOKClback
() {

1993 
HdSce
 
	gsce
;

1995 
	gback
->
Cl
(0, 
NULL
, 
async_sour
);

1998 
vtu
 
HdEClback
() {

1999 
HdSce
 
	gsce
;

2001 
	gv8
::
Lol
<
v8
::
Vue
> 
gv
[] = {

2002 
v8
::
Exi
::
E
(
New
<v8::
Sg
>(
EMesge
()).
ToLolChecked
())

2004 
	gback
->
Cl
(1, 
gv
, 
async_sour
);

2007 
SEMesge
(cڡ *
msg
) {

2008 
	gde
[] 
	grmsg_
;

2010 
size_t
 
	gsize
 = 

(
msg
) + 1;

2011 
	grmsg_
 = 
w
 [
size
];

2012 
memy
(
rmsg_
, 
msg
, 
size
);

2015 cڡ * 
EMesge
() const {

2016  
	grmsg_
;

2019 
	give
:

2020 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
AsyncWk
)

2021 *
rmsg_
;

2024  cs
	cAsyncBeProgssWkBa
 : 
public
 
AsyncWk
 {

2025 
public
:

2026 
exic
 
AsyncBeProgssWkBa
(

2027 
Clback
 *
back_
,

2028 cڡ * 
sour_me
 = "nan:AsyncBareProgressWorkerBase")

2029 : 
AsyncWk
(
back_
, 
sour_me
) {

2030 
uv_async_
(

2031 
GCutEvtLo
()

2032 , &
async


2033 , 
AsyncProgss_


2035 
	gasync
.
	gda
 = 
this
;

2038 
	gvtu
 ~
AsyncBeProgssWkBa
() {

2041 
vtu
 
WkProgss
() = 0;

2043 
vtu
 
Deroy
() {

2044 
uv_o
(
t_
<
uv_hd_t
*>(&
async
), 
AsyncClo_
);

2047 
	give
:

2048 
le
 
NAUV_WORK_CB
(
AsyncProgss_
) {

2049 
AsyncBeProgssWkBa
 *
wk
 =

2050 
ic_
<
AsyncBeProgssWkBa
*>(
async
->
da
);

2051 
	gwk
->
WkProgss
();

2054 
le
 
AsyncClo_
(
uv_hd_t
* 
hd
) {

2055 
AsyncBeProgssWkBa
 *
	gwk
 =

2056 
ic_
<
AsyncBeProgssWkBa
*>(
hd
->
da
);

2057 
de
 
	gwk
;

2060 
	geed
:

2061 
uv_async_t
 
async
;

2064 
	gme
<
ass
 
	gT
>

2066 as
	cAsyncBeProgssWk
 : 
public
 
AsyncBeProgssWkBa
 {

2067 
public
:

2068 
exic
 
AsyncBeProgssWk
(

2069 
Clback
 *
back_
,

2070 cڡ * 
sour_me
 = "nan:AsyncBareProgressWorker")

2071 : 
AsyncBeProgssWkBa
(
back_
, 
sour_me
) {

2072 
uv_mux_
(&
async_lock
);

2075 
	gvtu
 ~
AsyncBeProgssWk
() {

2076 
uv_mux_deroy
(&
async_lock
);

2079 as
	cExecutiProgss
 {

2080 
nd
 
ass
 
	gAsyncBeProgssWk
;

2081 
	gpublic
:

2082 
Sigl
() const {

2083 
uv_mux_lock
(&
th_
->
async_lock
);

2084 
uv_async_nd
(&
th_
->
async
);

2085 
uv_mux_uock
(&
th_
->
async_lock
);

2088 
Sd
(cڡ 
T
* 
da
, 
size_t
 
cou
) const {

2089 
	gth_
->
SdProgss_
(
da
, 
cou
);

2092 
	give
:

2093 
exic
 
ExecutiProgss
(
AsyncBeProgssWk
 *
th
: 
th_
(that) {}

2094 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
ExecutiProgss
)

2095 
AsyncBeProgssWk
* cڡ 
th_
;

2098 
vtu
 
Execu
(cڡ 
ExecutiProgss
& 
ogss
) = 0;

2099 
vtu
 
HdProgssClback
(cڡ 
T
 *
da
, 
size_t
 
size
) = 0;

2101 
	geed
:

2102 
uv_mux_t
 
async_lock
;

2104 
	give
:

2105 
Execu
() {

2106 
ExecutiProgss
 
ogss
(
this
);

2107 
Execu
(
ogss
);

2110 
vtu
 
SdProgss_
(cڡ 
T
 *
da
, 
size_t
 
cou
) = 0;

2113 
	gme
<
ass
 
	gT
>

2115 
ass
 
	gAsyncProgssWkBa
 : 
public
 
AsyncBeProgssWk
<
T
> {

2116 
public
:

2117 
exic
 
AsyncProgssWkBa
(

2118 
Clback
 *
back_
,

2119 cڡ * 
sour_me
 = "nan:AsyncProgressWorkerBase")

2120 : 
AsyncBeProgssWk
<
T
>(
back_
, 
	gsour_me
), 
asyncda_
(
NULL
),

2121 
asyncsize_
(0) {

2124 
	gvtu
 ~
AsyncProgssWkBa
() {

2125 
	gde
[] 
	gasyncda_
;

2128 
WkProgss
() {

2129 
uv_mux_lock
(&
this
->
async_lock
);

2130 
T
 *
	gda
 = 
asyncda_
;

2131 
size_t
 
	gsize
 = 
asyncsize_
;

2132 
	gasyncda_
 = 
NULL
;

2133 
	gasyncsize_
 = 0;

2134 
uv_mux_uock
(&
this
->
async_lock
);

2137 i(
	gthis
->
	gback
) {

2138 
	gthis
->
HdProgssClback
(
da
, 
size
);

2140 
	gde
[] 
	gda
;

2143 
	give
:

2144 
SdProgss_
(cڡ 
T
 *
da
, 
size_t
 
cou
) {

2145 
T
 *
	gw_da
 = 
w
 T[
cou
];

2146 
	gd
::
cy
(
da
, d+ 
cou
, 
w_da
);

2148 
uv_mux_lock
(&
this
->
async_lock
);

2149 
T
 *
	gd_da
 = 
asyncda_
;

2150 
	gasyncda_
 = 
w_da
;

2151 
	gasyncsize_
 = 
cou
;

2152 
uv_async_nd
(&
this
->
async
);

2153 
uv_mux_uock
(&
this
->
async_lock
);

2155 
	gde
[] 
	gd_da
;

2158 
T
 *
	gasyncda_
;

2159 
size_t
 
	gasyncsize_
;

2164 
	gAsyncProgssWkBa
<> 
	tAsyncProgssWk
;

2166 
	gme
<
ass
 
	gT
>

2168 as
	cAsyncBeProgssQueueWk
 : 
public
 
AsyncBeProgssWkBa
 {

2169 
public
:

2170 
exic
 
AsyncBeProgssQueueWk
(

2171 
Clback
 *
back_
,

2172 cڡ * 
sour_me
 = "nan:AsyncBareProgressQueueWorker")

2173 : 
AsyncBeProgssWkBa
(
back_
, 
sour_me
) {

2176 
	gvtu
 ~
AsyncBeProgssQueueWk
() {

2179 as
	cExecutiProgss
 {

2180 
nd
 
ass
 
	gAsyncBeProgssQueueWk
;

2181 
	gpublic
:

2182 
Sd
(cڡ 
T
* 
da
, 
size_t
 
cou
) const {

2183 
	gth_
->
SdProgss_
(
da
, 
cou
);

2186 
	give
:

2187 
exic
 
ExecutiProgss
(
AsyncBeProgssQueueWk
 *
th
)

2188 : 
th_
(
th
) {}

2189 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
ExecutiProgss
)

2190 
AsyncBeProgssQueueWk
* cڡ 
th_
;

2193 
vtu
 
Execu
(cڡ 
ExecutiProgss
& 
ogss
) = 0;

2194 
vtu
 
HdProgssClback
(cڡ 
T
 *
da
, 
size_t
 
size
) = 0;

2196 
	give
:

2197 
Execu
() {

2198 
ExecutiProgss
 
ogss
(
this
);

2199 
Execu
(
ogss
);

2202 
vtu
 
SdProgss_
(cڡ 
T
 *
da
, 
size_t
 
cou
) = 0;

2205 
	gme
<
ass
 
	gT
>

2207 
ass
 
	gAsyncProgssQueueWk
 : 
public
 
AsyncBeProgssQueueWk
<
T
> {

2208 
public
:

2209 
exic
 
AsyncProgssQueueWk
(

2210 
Clback
 *
back_
,

2211 cڡ * 
sour_me
 = "nan:AsyncProgressQueueWorker")

2212 : 
AsyncBeProgssQueueWk
<
T
>(
back_
) {

2213 
uv_mux_
(&
async_lock
);

2216 
	gvtu
 ~
AsyncProgssQueueWk
() {

2217 
uv_mux_lock
(&
async_lock
);

2219 !
	gasyncda_
.
emy
()) {

2220 
	gd
::

<
T
*, 
	gsize_t
> &
	gda
 = 
asyncda_
.
t
();

2221 
T
 *
	gda
 = 
da
.
f
;

2223 
	gasyncda_
.
p
();

2225 
	gde
[] 
	gda
;

2228 
uv_mux_uock
(&
async_lock
);

2229 
uv_mux_deroy
(&
async_lock
);

2232 
WkCome
() {

2233 
WkProgss
();

2234 
	gAsyncWk
::
WkCome
();

2237 
WkProgss
() {

2238 
uv_mux_lock
(&
async_lock
);

2240 !
	gasyncda_
.
emy
()) {

2241 
	gd
::

<
T
*, 
	gsize_t
> &
	gda
 = 
asyncda_
.
t
();

2243 
T
 *
	gda
 = 
da
.
f
;

2244 
size_t
 
	gsize
 = 
da
.
cd
;

2246 
	gasyncda_
.
p
();

2247 
uv_mux_uock
(&
async_lock
);

2250 i(
	gthis
->
	gback
) {

2251 
	gthis
->
HdProgssClback
(
da
, 
size
);

2254 
	gde
[] 
	gda
;

2256 
uv_mux_lock
(&
async_lock
);

2259 
uv_mux_uock
(&
async_lock
);

2262 
	give
:

2263 
SdProgss_
(cڡ 
T
 *
da
, 
size_t
 
cou
) {

2264 
T
 *
	gw_da
 = 
w
 T[
cou
];

2265 
	gd
::
cy
(
da
, d+ 
cou
, 
w_da
);

2267 
uv_mux_lock
(&
async_lock
);

2268 
	gasyncda_
.
push
(
d
::

<
T
*, 
size_t
>(
w_da
, 
cou
));

2269 
uv_mux_uock
(&
async_lock
);

2271 
uv_async_nd
(&
this
->
async
);

2274 
uv_mux_t
 
	gasync_lock
;

2275 
	gd
::
queue
<
d
::

<
T
*, 
	gsize_t
> > 
	gasyncda_
;

2278 
le
 
	$AsyncExecu
 (
uv_wk_t
* 
q
) {

2279 
AsyncWk
 *
wk
 = 
ic_
<AsyncWk*>(
q
->
da
);

2280 
wk
->
	`Execu
();

2281 
	}
}

2287 
le
 
	$AsyncExecuCome
(
uv_wk_t
 *
q
) {

2288 
AsyncWk
* 
wk
 = 
ic_
<AsyncWk*>(
q
->
da
);

2289 
wk
->
	`WkCome
();

2290 
wk
->
	`Deroy
();

2291 
	}
}

2292 
le
 
	$AsyncExecuCome
 (
uv_wk_t
* 
q
, 
us
) {

2293 
	`AsyncExecuCome
(
q
);

2294 
	}
}

2296 
le
 
	$AsyncQueueWk
 (
AsyncWk
* 
wk
) {

2297 
	`uv_queue_wk
(

2298 
	`GCutEvtLo
()

2299 , &
wk
->
que


2300 , 
AsyncExecu


2301 , 
AsyncExecuCome


2303 
	}
}

2305 
mea
 
	gimp
 {

2307 
le


2308 
ExOBySgResour
 const*

2309 
GExResour
(
v8
::
Lol
<v8::
Sg
> 
r
) {

2310 #i
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION


2311  
r
->
GExAsciiSgResour
();

2313  
	gr
->
GExOBySgResour
();

2317 
le


2318 
bo


2319 
IsEx
(
v8
::
Lol
<v8::
Sg
> 
r
) {

2320 #i
NODE_MODULE_VERSION
 < 
ATOM_0_21_MODULE_VERSION


2321  
r
->
IsExAscii
();

2323  
	gr
->
IsExOBy
();

2329 
	eEncodg
 {
	gASCII
, 
	gUTF8
, 
	gBASE64
, 
	gUCS2
, 
	gBINARY
, 
	gHEX
, 
	gBUFFER
};

2331 #i
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION


2332 
	~"n_rg_bys.h
"

2335 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Encode
(

2336 cڡ *
buf
, 
size_t
 
n
, 
Encodg
 
codg
 = 
BINARY
) {

2337 #i(
NODE_MODULE_VERSION
 >
ATOM_0_21_MODULE_VERSION
)

2338 
v8
::
Isީe
* 
isީe
 = v8::Isީe::
	`GCut
();

2339 
node
::
codg
 
node_c
 = 
ic_
<node::encoding>(encoding);

2341 i(
codg
 =
UCS2
) {

2342  
node
::
	`Encode
(

2343 
isީe


2344 , 
t_
<cڡ 
ut16_t
 *>(
buf
)

2345 , 
n
 / 2);

2347  
node
::
	`Encode
(

2348 
isީe


2349 , 
t_
<cڡ *>(
buf
)

2350 , 
n


2351 , 
node_c
);

2353 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

2354  
node
::
	`Encode
(

2355 
v8
::
Isީe
::
	`GCut
()

2356 , 
buf
, 
n


2357 , 
ic_
<
node
::
codg
>(encoding));

2359 #i
NODE_MODULE_VERSION
 >
NODE_0_10_MODULE_VERSION


2360  
node
::
	`Encode
(
buf
, 
n
, 
ic_
<node::
codg
>(encoding));

2362  
imp
::
	`Encode
(
t_
<cڡ *>(
buf
), 
n
, 
codg
);

2365 
	}
}

2367 
le
 
ssize_t
 
DecodeBys
(

2368 
v8
::
Lol
<v8::
Vue
> 
v
, 
Encodg
 
codg
 = 
BINARY
) {

2369 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

2370  
node
::
DecodeBys
(

2371 
v8
::
Isީe
::
GCut
()

2372 , 
v


2373 , 
ic_
<
node
::
codg
>(encoding));

2375 #i(
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION
)

2376 i(
	gcodg
 =
BUFFER
) {

2377  
node
::
DecodeBys
(
v
,ode::
BINARY
);

2380  
	gnode
::
DecodeBys
(
v
, 
ic_
<
node
::
codg
>(encoding));

2384 
le
 
ssize_t
 
DecodeWre
(

2385 *
buf


2386 , 
size_t
 
n


2387 , 
v8
::
Lol
<v8::
Vue
> 
v


2388 , 
Encodg
 
codg
 = 
BINARY
) {

2389 #i(
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION
)

2390  
node
::
DecodeWre
(

2391 
v8
::
Isީe
::
GCut
()

2392 , 
buf


2393 , 
n


2394 , 
v


2395 , 
ic_
<
node
::
codg
>(encoding));

2397 #i(
NODE_MODULE_VERSION
 < 
NODE_0_10_MODULE_VERSION
)

2398 i(
	gcodg
 =
BUFFER
) {

2399  
node
::
DecodeWre
(
buf
, 
n
, 
v
,ode::
BINARY
);

2402  
	gnode
::
DecodeWre
(

2403 
buf


2404 , 
n


2405 , 
v


2406 , 
ic_
<
node
::
codg
>(encoding));

2410 
le
 
SPryTeme
(

2411 
v8
::
Lol
<v8::
FuniTeme
> 
m


2412 , cڡ *
me


2413 , 
v8
::
Lol
<v8::
Da
> 
vue


2415 
HdSce
 
sce
;

2416 
STeme
(
m
->
PryTeme
(), 
me
, 
vue
);

2419 
le
 
SPryTeme
(

2420 
v8
::
Lol
<v8::
FuniTeme
> 
m


2421 , 
v8
::
Lol
<v8::
Sg
> 
me


2422 , 
v8
::
Lol
<v8::
Da
> 
vue


2423 , 
v8
::
PrݔtyAribu
 
ibus


2425 
HdSce
 
sce
;

2426 
STeme
(
m
->
PryTeme
(), 
me
, 
vue
, 
ibus
);

2429 
le
 
SInTeme
(

2430 
v8
::
Lol
<v8::
FuniTeme
> 
m


2431 , cڡ *
me


2432 , 
v8
::
Lol
<v8::
Da
> 
vue


2434 
HdSce
 
sce
;

2435 
STeme
(
m
->
InTeme
(), 
me
, 
vue
);

2438 
le
 
SInTeme
(

2439 
v8
::
Lol
<v8::
FuniTeme
> 
m


2440 , 
v8
::
Lol
<v8::
Sg
> 
me


2441 , 
v8
::
Lol
<v8::
Da
> 
vue


2442 , 
v8
::
PrݔtyAribu
 
ibus


2444 
HdSce
 
sce
;

2445 
STeme
(
m
->
InTeme
(), 
me
, 
vue
, 
ibus
);

2448 
mea
 
	gimp
 {

2454 
	gme
 <
tyme
 
	gT
>

2455 
le


2457 
SMhodAux
(
T
 
cv
,

2458 
v8
::
Lol
<v8::
Sg
> 
me
,

2459 
v8
::
Lol
<v8::
FuniTeme
> 
l
,

2460 
v8
::
Teme
 *) {

2461 
cv
->
S
(
me
, 
l
);

2464 
	gme
 <
tyme
 
	gT
>

2465 
le


2467 
SMhodAux
(
T
 
cv
,

2468 
v8
::
Lol
<v8::
Sg
> 
me
,

2469 
v8
::
Lol
<v8::
FuniTeme
> 
l
,

2471 
S
(
cv
, 
me
, 
GFuni
(
l
).
ToLolChecked
());

2476 
	gme
 <
tyme
 
	gT
,em<
	gtyme
> 
ass
 
	gHdTy
>

2477 
le
 
SMhod
(

2478 
HdTy
<
T
> 
cv


2479 , cڡ *
me


2480 , 
FuniClback
 
back


2481 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2482 
HdSce
 
sce
;

2483 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
t
 = 
New
<v8::FuniTeme>(
back
, 
	gda
);

2484 
	gv8
::
Lol
<
v8
::
Sg
> 
_me
 = 
New
(
me
).
ToLolChecked
();

2485 
	gt
->
SCssName
(
_me
);

2488 
	gimp
::
SMhodAux
(
cv
, 
_me
, 
t
, 
ic_
<
T
*>(0));

2491 
le
 
SPryMhod
(

2492 
v8
::
Lol
<v8::
FuniTeme
> 
cv


2493 , cڡ * 
me


2494 , 
FuniClback
 
back


2495 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2496 
HdSce
 
sce
;

2497 
	gv8
::
Lol
<
v8
::
FuniTeme
> 
t
 = 
New
<v8::FunctionTemplate>(

2498 
back


2499 , 
	gda


2500 , 
	gNew
<
	gv8
::
Sigtu
>(
cv
));

2501 
	gv8
::
Lol
<
v8
::
Sg
> 
_me
 = 
New
(
me
).
ToLolChecked
();

2502 
	gcv
->
PryTeme
()->
S
(
_me
, 
t
);

2503 
	gt
->
SCssName
(
_me
);

2508 
le
 
SAcss
(

2509 
v8
::
Lol
<v8::
ObjeTeme
> 
l


2510 , 
v8
::
Lol
<v8::
Sg
> 
me


2511 , 
GrClback
 
gr


2512 , 
SrClback
 

 = 0

2513 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

2514 , 
v8
::
AcssCڌ
 
gs
 = v8::
DEFAULT


2515 , 
v8
::
PrݔtyAribu
 
ibu
 = v8::
Ne


2516 , 
imp
::
Sig
 
sigtu
 = imp::
	$Sig
()) {

2517 
HdSce
 
sce
;

2519 
imp
::
NiveGr
 
gr_
 =

2520 
imp
::
GrClbackW
;

2521 
imp
::
NiveSr
 
_
 =

2522 

 ? 
imp
::
SrClbackW
 : 0;

2524 
v8
::
Lol
<v8::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2525 
ٶ
->
	`SIlFldCou
(
imp
::
kAcssFldCou
);

2526 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
	`NewIn
(
ٶ
).
	`ToLolChecked
();

2528 
obj
->
	`SIlFld
(

2529 
imp
::
kGrIndex


2530 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2532 i(

 != 0) {

2533 
obj
->
	`SIlFld
(

2534 
imp
::
kSrIndex


2535 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2538 i(!
da
.
	`IsEmy
()) {

2539 
obj
->
	`SIlFld
(
imp
::
kDaIndex
, 
da
);

2542 
l
->
	`SAcss
(

2543 
me


2544 , 
gr_


2545 , 
_


2546 , 
obj


2547 , 
gs


2548 , 
ibu


2549 , 
sigtu
);

2550 
	}
}

2552 
le
 
bo
 
SAcss
(

2553 
v8
::
Lol
<v8::
Obje
> 
obj


2554 , 
v8
::
Lol
<v8::
Sg
> 
me


2555 , 
GrClback
 
gr


2556 , 
SrClback
 

 = 0

2557 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

2558 , 
v8
::
AcssCڌ
 
gs
 = v8::
DEFAULT


2559 , 
v8
::
PrݔtyAribu
 
ibu
 = v8::
Ne
) {

2560 
HdSce
 
sce
;

2562 
	gimp
::
NiveGr
 
gr_
 =

2563 
imp
::
GrClbackW
;

2564 
	gimp
::
NiveSr
 
_
 =

2565 

 ? 
imp
::
SrClbackW
 : 0;

2567 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2568 
	gٶ
->
SIlFldCou
(
imp
::
kAcssFldCou
);

2569 
	gv8
::
Lol
<
v8
::
Obje
> 
daobj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2571 
	gdaobj
->
SIlFld
(

2572 
imp
::
kGrIndex


2573 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2575 i(!
	gda
.
IsEmy
()) {

2576 
	gdaobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2579 i(
	g
) {

2580 
	gdaobj
->
SIlFld
(

2581 
imp
::
kSrIndex


2582 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2585 #i(
NODE_MODULE_VERSION
 >
NODE_6_0_MODULE_VERSION
)

2586  
	gobj
->
SAcss
(

2587 
GCutCڋxt
()

2588 , 
me


2589 , 
gr_


2590 , 
_


2591 , 
daobj


2592 , 
gs


2593 , 
ibu
).
FromMaybe
(
l
);

2595  
	gobj
->
SAcss
(

2596 
me


2597 , 
gr_


2598 , 
_


2599 , 
daobj


2600 , 
gs


2601 , 
ibu
);

2605 
le
 
SNamedPrݔtyHdr
(

2606 
v8
::
Lol
<v8::
ObjeTeme
> 
l


2607 , 
PrݔtyGrClback
 
gr


2608 , 
PrݔtySrClback
 

 = 0

2609 , 
PrݔtyQuyClback
 
quy
 = 0

2610 , 
PrݔtyDClback
 
d
 = 0

2611 , 
PrݔtyEnumClback
 
um
 = 0

2612 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2613 
HdSce
 
sce
;

2615 
	gimp
::
NivePrݔtyGr
 
gr_
 =

2616 
imp
::
PrݔtyGrClbackW
;

2617 
	gimp
::
NivePrݔtySr
 
_
 =

2618 

 ? 
imp
::
PrݔtySrClbackW
 : 0;

2619 
	gimp
::
NivePrݔtyQuy
 
quy_
 =

2620 
quy
 ? 
imp
::
PrݔtyQuyClbackW
 : 0;

2621 
	gimp
::
NivePrݔtyD
 *
d_
 =

2622 
d
 ? 
imp
::
PrݔtyDClbackW
 : 0;

2623 
	gimp
::
NivePrݔtyEnum
 
um_
 =

2624 
um
 ? 
imp
::
PrݔtyEnumClbackW
 : 0;

2626 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2627 
	gٶ
->
SIlFldCou
(
imp
::
kPrݔtyFldCou
);

2628 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2629 
	gobj
->
SIlFld
(

2630 
imp
::
kPrݔtyGrIndex


2631 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2633 i(
	g
) {

2634 
	gobj
->
SIlFld
(

2635 
imp
::
kPrݔtySrIndex


2636 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2639 i(
	gquy
) {

2640 
	gobj
->
SIlFld
(

2641 
imp
::
kPrݔtyQuyIndex


2642 , 
New
<
v8
::
Ex
>(
t_
<*>(
quy
)));

2645 i(
	gd
) {

2646 
	gobj
->
SIlFld
(

2647 
imp
::
kPrݔtyDIndex


2648 , 
New
<
v8
::
Ex
>(
t_
<*>(
d
)));

2651 i(
	gum
) {

2652 
	gobj
->
SIlFld
(

2653 
imp
::
kPrݔtyEnumIndex


2654 , 
New
<
v8
::
Ex
>(
t_
<*>(
um
)));

2657 i(!
	gda
.
IsEmy
()) {

2658 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2661 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


2662 
	gl
->
SHdr
(
v8
::
NamedPrݔtyHdrCfiguti
(

2663 
gr_
, 
_
, 
quy_
, 
d_
, 
um_
, 
obj
));

2665 
	gl
->
SNamedPrݔtyHdr
(

2666 
gr_


2667 , 
_


2668 , 
quy_


2669 , 
d_


2670 , 
um_


2671 , 
obj
);

2675 
le
 
SIndexedPrݔtyHdr
(

2676 
v8
::
Lol
<v8::
ObjeTeme
> 
l


2677 , 
IndexGrClback
 
gr


2678 , 
IndexSrClback
 

 = 0

2679 , 
IndexQuyClback
 
quy
 = 0

2680 , 
IndexDClback
 
d
 = 0

2681 , 
IndexEnumClback
 
um
 = 0

2682 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2683 
HdSce
 
sce
;

2685 
	gimp
::
NiveIndexGr
 
gr_
 =

2686 
imp
::
IndexGrClbackW
;

2687 
	gimp
::
NiveIndexSr
 
_
 =

2688 

 ? 
imp
::
IndexSrClbackW
 : 0;

2689 
	gimp
::
NiveIndexQuy
 
quy_
 =

2690 
quy
 ? 
imp
::
IndexQuyClbackW
 : 0;

2691 
	gimp
::
NiveIndexD
 
d_
 =

2692 
d
 ? 
imp
::
IndexDClbackW
 : 0;

2693 
	gimp
::
NiveIndexEnum
 
um_
 =

2694 
um
 ? 
imp
::
IndexEnumClbackW
 : 0;

2696 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2697 
	gٶ
->
SIlFldCou
(
imp
::
kIndexPrݔtyFldCou
);

2698 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2699 
	gobj
->
SIlFld
(

2700 
imp
::
kIndexPrݔtyGrIndex


2701 , 
New
<
v8
::
Ex
>(
t_
<*>(
gr
)));

2703 i(
	g
) {

2704 
	gobj
->
SIlFld
(

2705 
imp
::
kIndexPrݔtySrIndex


2706 , 
New
<
v8
::
Ex
>(
t_
<*>(

)));

2709 i(
	gquy
) {

2710 
	gobj
->
SIlFld
(

2711 
imp
::
kIndexPrݔtyQuyIndex


2712 , 
New
<
v8
::
Ex
>(
t_
<*>(
quy
)));

2715 i(
	gd
) {

2716 
	gobj
->
SIlFld
(

2717 
imp
::
kIndexPrݔtyDIndex


2718 , 
New
<
v8
::
Ex
>(
t_
<*>(
d
)));

2721 i(
	gum
) {

2722 
	gobj
->
SIlFld
(

2723 
imp
::
kIndexPrݔtyEnumIndex


2724 , 
New
<
v8
::
Ex
>(
t_
<*>(
um
)));

2727 i(!
	gda
.
IsEmy
()) {

2728 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2731 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


2732 
	gl
->
SHdr
(
v8
::
IndexedPrݔtyHdrCfiguti
(

2733 
gr_
, 
_
, 
quy_
, 
d_
, 
um_
, 
obj
));

2735 
	gl
->
SIndexedPrݔtyHdr
(

2736 
gr_


2737 , 
_


2738 , 
quy_


2739 , 
d_


2740 , 
um_


2741 , 
obj
);

2745 
le
 
SClHdr
(

2746 
v8
::
Lol
<v8::
FuniTeme
> 
l


2747 , 
FuniClback
 
back


2748 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2749 
HdSce
 
sce
;

2751 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2752 
	gٶ
->
SIlFldCou
(
imp
::
kFuniFldCou
);

2753 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2755 
	gobj
->
SIlFld
(

2756 
imp
::
kFuniIndex


2757 , 
New
<
v8
::
Ex
>(
t_
<*>(
back
)));

2759 i(!
	gda
.
IsEmy
()) {

2760 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2763 
	gl
->
SClHdr
(
imp
::
FuniClbackW
, 
obj
);

2767 
le
 
SClAsFuniHdr
(

2768 
v8
::
Lol
<v8::
ObjeTeme
> 
l
,

2769 
FuniClback
 
back
,

2770 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

2771 
HdSce
 
sce
;

2773 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
ٶ
 = 
New
<v8::ObjectTemplate>();

2774 
	gٶ
->
SIlFldCou
(
imp
::
kFuniFldCou
);

2775 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
ٶ
).
ToLolChecked
();

2777 
	gobj
->
SIlFld
(

2778 
imp
::
kFuniIndex


2779 , 
New
<
v8
::
Ex
>(
t_
<*>(
back
)));

2781 i(!
	gda
.
IsEmy
()) {

2782 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
da
);

2785 
	gl
->
SClAsFuniHdr
(
imp
::
FuniClbackW
, 
obj
);

2790 
	~"n_wk.h
"

2794 
	~"n_obje_wp.h
"

2798 
	~"n_ive.h
"

2802 
le


2804 
	$Expt
(
ADDON_REGISTER_FUNCTION_ARGS_TYPE
 
rg
, cڡ *
me
,

2805 
FuniClback
 
f
) {

2806 
HdSce
 
sce
;

2808 
	`S
(
rg
, 
New
<
v8
::
Sg
>(
me
).
	`ToLolChecked
(),

2809 
	`GFuni
(
New
<
v8
::
FuniTeme
>(
f
)).
	`ToLolChecked
());

2810 
	}
}

2814 
	sT
 {

2815 
exic
 
T
(
v8
::
Lol
<v8::
Vue
> 
t
: 
t_
() {

2816 
HdSce
 
sce
;

2818 
	gt_
.
Ret
(
To
<
v8
::
Obje
>(
t
).
ToLolChecked
());

2821 ~
T
({ 
	gt_
.
Ret
(); }

2823 
le
 

(
i
) {

2824 
HdSce
 
	gsce
;

2825 
	gv8
::
Lol
<
v8
::
Vue
> 
g
 = 
New
(
i
);

2826 
Cl
("", 
New
(
t_
), 1, &
g
);

2829 
le
 
ok
(
bo
 
isOk
, cڡ *
msg
 = 
NULL
) {

2830 
HdSce
 
sce
;

2831 
	gv8
::
Lol
<
v8
::
Vue
> 
gs
[2];

2832 
	ggs
[0] = 
New
(
isOk
);

2833 i(
	gmsg

	ggs
[1] = 
New
(
msg
).
ToLolChecked
();

2834 
Cl
("ok", 
New
(
t_
), 
msg
 ? 2 : 1, 
gs
);

2837 
le
 
ss
(cڡ * 
msg
 = 
NULL
) {

2838 
HdSce
 
sce
;

2839 
	gv8
::
Lol
<
v8
::
Vue
> 
hmsg
;

2840 i(
	gmsg

	ghmsg
 = 
New
(
msg
).
ToLolChecked
();

2841 
Cl
("ss", 
New
(
t_
), 
msg
 ? 1 : 0, &
hmsg
);

2844 
le
 
d
() {

2845 
HdSce
 
	gsce
;

2846 
Cl
("d", 
New
(
t_
), 0, 
NULL
);

2849 
	give
:

2850 
Psit
<
v8
::
Obje
> 
t_
;

2853 
	#NAN_STRINGIZE2
(
x
#x

	)

2854 
	#NAN_STRINGIZE
(
x

	$NAN_STRINGIZE2
(
x
)

	)

2855 
	#NAN_TEST_EXPRESSION
(
exessi
) \

2856 
exessi
 ), 
__FILE__
 ":" 
	`NAN_STRINGIZE
(
__LINE__
": " #exessi

	)

2858 
	#NAN_EXPORT
(
rg
, 
funi

	`Expt
Ѭg, #funi, funi)

	)

2860 #unde
TYPE_CHECK


2864 
mea
 
imp
 {

2866 
me
 <
tyme
 
T
> 
Maybefr
;

2868 
me
 <
tyme
 
T
> 
Maybefr
<
v8
::
Lol
<T> > {

2869 
le
 
MaybeLol
<
T
> 
	`cvt
(
v8
::
Lol
<T> 
v
) {

2870  
v
;

2874 
me
 <
tyme
 
T
> 
Maybefr
<
MaybeLol
<T> > {

2875 
le
 
MaybeLol
<
T
> 
	`cvt
(MaybeLol<T> 
v
) {

2876  
v
;

2880 
	}
}

2882 
	gme
 <
tyme
 
	gT
,em<
	gtyme
> 
ass
 
	gMaybeMaybe
>

2883 
le
 
	gMaybeLol
<
	gT
>

2884 
MakeMaybe
(
MaybeMaybe
<
T
> 
v
) {

2885  
	gimp
::
Maybefr
<
MaybeMaybe
<
T
> >::
cvt
(
v
);

2890 
	~"n_tydy_cڋs.h
"

2894 
	~"n_js.h
"

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_callbacks.h

9 #ide
NAN_CALLBACKS_H_


10 
	#NAN_CALLBACKS_H_


	)

12 
	gme
<
tyme
 
	gT
> 
ass
 
	gFuniClbackInfo
;

13 
	gme
<
tyme
 
	gT
> 
ass
 
	gPrݔtyClbackInfo
;

14 
	gme
<
tyme
 
	gT
> 
ass
 
	gGlob
;

16 (*
	tFuniClback
)(cڡ 
	tFuniClbackInfo
<
	tv8
::
	tVue
>&);

17 (*
	tGrClback
)

18 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ 
	tPrݔtyClbackInfo
<v8::
	tVue
>&);

19 (*
	tSrClback
)(

20 
	tv8
::
	tLol
<v8::
	tSg
>,

21 
	tv8
::
	tLol
<v8::
	tVue
>,

22 cڡ 
	tPrݔtyClbackInfo
<>&);

23 (*
	tPrݔtyGrClback
)(

24 
	tv8
::
	tLol
<v8::
	tSg
>,

25 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

26 (*
	tPrݔtySrClback
)(

27 
	tv8
::
	tLol
<v8::
	tSg
>,

28 
	tv8
::
	tLol
<v8::
	tVue
>,

29 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

30 (*
	tPrݔtyEnumClback
)

31 (cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&);

32 (*
	tPrݔtyDClback
)(

33 
	tv8
::
	tLol
<v8::
	tSg
>,

34 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&);

35 (*
	tPrݔtyQuyClback
)(

36 
	tv8
::
	tLol
<v8::
	tSg
>,

37 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&);

38 (*
	tIndexGrClback
)(

39 
	tut32_t
,

40 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

41 (*
	tIndexSrClback
)(

42 
	tut32_t
,

43 
	tv8
::
	tLol
<v8::
	tVue
>,

44 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tVue
>&);

45 (*
	tIndexEnumClback
)

46 (cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tAay
>&);

47 (*
	tIndexDClback
)(

48 
	tut32_t
,

49 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tBoޗn
>&);

50 (*
	tIndexQuyClback
)(

51 
	tut32_t
,

52 cڡ 
	tPrݔtyClbackInfo
<
	tv8
::
	tIeg
>&);

54 
mea
 
imp
 {

55 
v8
::
	tLol
<
	tv8
::
	tAcssSigtu
> 
	tSig
;

57 cڡ 
kDaIndex
 = 0;

59 cڡ 
kFuniIndex
 = 1;

60 cڡ 
kFuniFldCou
 = 2;

62 cڡ 
kGrIndex
 = 1;

63 cڡ 
kSrIndex
 = 2;

64 cڡ 
kAcssFldCou
 = 3;

66 cڡ 
kPrݔtyGrIndex
 = 1;

67 cڡ 
kPrݔtySrIndex
 = 2;

68 cڡ 
kPrݔtyEnumIndex
 = 3;

69 cڡ 
kPrݔtyDIndex
 = 4;

70 cڡ 
kPrݔtyQuyIndex
 = 5;

71 cڡ 
kPrݔtyFldCou
 = 6;

73 cڡ 
kIndexPrݔtyGrIndex
 = 1;

74 cڡ 
kIndexPrݔtySrIndex
 = 2;

75 cڡ 
kIndexPrݔtyEnumIndex
 = 3;

76 cڡ 
kIndexPrݔtyDIndex
 = 4;

77 cڡ 
kIndexPrݔtyQuyIndex
 = 5;

78 cڡ 
kIndexPrݔtyFldCou
 = 6;

80 
	}
}

82 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


83 
	~"n_backs_12_l.h
"

85 
	~"n_backs_e_12_l.h
"

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_callbacks_12_inl.h

9 #ide
NAN_CALLBACKS_12_INL_H_


10 
	#NAN_CALLBACKS_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cRuVue
 {

14 
	mv8
::
RuVue
<
T
> 
vue_
;

16 
	mpublic
:

17 
me
 <
ass
 
S
>

18 
exic
 
le
 
RuVue
(cڡ 
v8
::RuVue<
S
> &
vue
) :

19 
	$vue_
(
vue
) {}

20 
me
 <
ass
 
S
>

21 
exic
 
le
 
	`RuVue
(cڡ 
RuVue
<
S
>& 
th
)

22 : 
	$vue_
(
th
.
vue_
) {

23 
	`TYPE_CHECK
(
T
, 
S
);

24 
	}
}

27 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
v8
::
Lol
<
S
> &
hd
) {

28 
TYPE_CHECK
(
T
, 
S
);

29 
	gvue_
.
S
(
hd
);

32 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
Glob
<
S
> &
hd
) {

33 
TYPE_CHECK
(
T
, 
S
);

34 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

35 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && \

36 (
V8_MINOR_VERSION
 > 5 || (V8_MINOR_VERSION == 5 && \

37 
defed
(
V8_BUILD_NUMBER
) && V8_BUILD_NUMBER >= 8))))

38 
vue_
.
S
(
hd
);

40 
	gvue_
.
S
(*
t_
<cڡ 
v8
::
Psit
<
S
>*>(&
hd
));

41 
	gcڡ_
<
	gGlob
<
	gS
> &>(
	ghd
).
Ret
();

46 
le
 
	$S
(
bo
 
vue
) {

47 
	`TYPE_CHECK
(
T
, 
v8
::
Boޗn
);

48 
vue_
.
	`S
(
vue
);

49 
	}
}

51 
le
 
	$S
(
i
) {

52 
	`TYPE_CHECK
(
T
, 
v8
::
Numb
);

53 
vue_
.
	`S
(
i
);

54 
	}
}

56 
le
 
	$S
(
t32_t
 
i
) {

57 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

58 
vue_
.
	`S
(
i
);

59 
	}
}

61 
le
 
	$S
(
ut32_t
 
i
) {

62 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

63 
vue_
.
	`S
(
i
);

64 
	}
}

67 
le
 
	$SNu
() {

68 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

69 
vue_
.
	`SNu
();

70 
	}
}

72 
le
 
	$SUndefed
() {

73 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

74 
vue_
.
	`SUndefed
();

75 
	}
}

77 
le
 
	$SEmySg
() {

78 
	`TYPE_CHECK
(
T
, 
v8
::
Sg
);

79 
vue_
.
	`SEmySg
();

80 
	}
}

83 
le
 
	gv8
::
Isީe
 *
	$GIsީe
() const {

84  
vue_
.
	`GIsީe
();

85 
	}
}

88 
	gme
<
tyme
 
	gS
>

89 
le
 
	$S
(
S
 *
whev
{ 
	`TYPE_CHECK
(S*, 
v8
::
Primive
); 
	}
}

92 
	gme
<
tyme
 
	gT
>

93 as
	cFuniClbackInfo
 {

94 cڡ 
	mv8
::
FuniClbackInfo
<
T
> &
fo_
;

95 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

97 
	mpublic
:

98 
exic
 
le
 
FuniClbackInfo
(

99 cڡ 
v8
::
FuniClbackInfo
<
T
> &
fo


100 , 
v8
::
Lol
<v8::
Vue
> 
da
) :

101 
fo_
(
fo
)

102 , 
	$da_
(
da
) {}

104 
le
 
RuVue
<
T
> 
	$GRuVue
() const {

105  
RuVue
<
T
>(
fo_
.
	`GRuVue
());

106 
	}
}

108 #i
NODE_MAJOR_VERSION
 < 10

109 
le
 
	gv8
::
Lol
<
v8
::
Funi
> 
	$Ce
(cڡ {  
fo_
.
	`Ce
(); 
	}
}

111 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

112 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

113 
le
 
bo
 
	$IsCڡruCl
(cڡ {  
fo_
.
	`IsCڡruCl
(); 
	}
}

114 
le
 
	$Lgth
(cڡ {  
fo_
.
	`Lgth
(); 
	}
}

115 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
ݔ
[](
i
cڡ {  
fo_
[i]; }

116 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

117 
le
 
	gv8
::
Isީe
 *
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

120 
	geed
:

121 cڡ 
kHdIndex
 = 0;

122 cڡ 
	gkIsީeIndex
 = 1;

123 cڡ 
	gkRuVueDeuVueIndex
 = 2;

124 cڡ 
	gkRuVueIndex
 = 3;

125 cڡ 
	gkDaIndex
 = 4;

126 cڡ 
	gkCeIndex
 = 5;

127 cڡ 
	gkCڋxtSaveIndex
 = 6;

128 cڡ 
	gkArgsLgth
 = 7;

130 
	give
:

131 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
FuniClbackInfo
)

134 
	gme
<
tyme
 
	gT
>

135 as
	cPrݔtyClbackInfo
 {

136 cڡ 
	mv8
::
PrݔtyClbackInfo
<
T
> &
fo_
;

137 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

139 
	mpublic
:

140 
exic
 
le
 
PrݔtyClbackInfo
(

141 cڡ 
v8
::
PrݔtyClbackInfo
<
T
> &
fo


142 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

143 
fo_
(
fo
)

144 , 
	$da_
(
da
) {}

146 
le
 
v8
::
Isީe
* 
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

147 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

148 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

149 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

150 
le
 
	gRuVue
<
	gT
> 
	$GRuVue
() const {

151  
RuVue
<
T
>(
fo_
.
	`GRuVue
());

152 
	}
}

154 
	geed
:

155 cڡ 
kHdIndex
 = 0;

156 cڡ 
	gkIsީeIndex
 = 1;

157 cڡ 
	gkRuVueDeuVueIndex
 = 2;

158 cڡ 
	gkRuVueIndex
 = 3;

159 cڡ 
	gkDaIndex
 = 4;

160 cڡ 
	gkThisIndex
 = 5;

161 cڡ 
	gkArgsLgth
 = 6;

163 
	give
:

164 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
PrݔtyClbackInfo
)

167 
mea
 
	gimp
 {

169 
FuniClbackW
(cڡ 
v8
::
FuniClbackInfo
<v8::
Vue
> &
fo
) {

170 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

171 
FuniClback
 
	gback
 = 
t_
<FunctionCallback>(

172 
t_
<
_t
>(

173 
obj
->
GIlFld
(
kFuniIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

174 
	gFuniClbackInfo
<
	gv8
::
Vue
>

175 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

176 
back
(
cbfo
);

179 (*
	gNiveFuni
)(cڡ 
	tv8
::
	tFuniClbackInfo
<v8::
	tVue
> &);

181 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


183 
GrClbackW
(

184 
v8
::
Lol
<v8::
Name
> 
ݔty


185 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

186 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

187 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

188 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

189 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

190 
t_
<
_t
>(

191 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

192 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

195 (*
	gNiveGr
)

196 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

199 
SrClbackW
(

200 
v8
::
Lol
<v8::
Name
> 
ݔty


201 , 
v8
::
Lol
<v8::
Vue
> 
vue


202 , cڡ 
v8
::
PrݔtyClbackInfo
<> &
fo
) {

203 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

204 
	gPrݔtyClbackInfo
<>

205 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

206 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

207 
t_
<
_t
>(

208 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

209 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
vue
, 
cbfo
);

212 (*
	gNiveSr
)(

213 
	tv8
::
	tLol
<v8::
	tName
>

214 , 
	tv8
::
	tLol
<v8::
	tVue
>

215 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<> &);

218 
GrClbackW
(

219 
v8
::
Lol
<v8::
Sg
> 
ݔty


220 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

221 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

222 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

223 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

224 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

225 
t_
<
_t
>(

226 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

227 
back
(
ݔty
, 
cbfo
);

230 (*
	gNiveGr
)

231 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

234 
SrClbackW
(

235 
v8
::
Lol
<v8::
Sg
> 
ݔty


236 , 
v8
::
Lol
<v8::
Vue
> 
vue


237 , cڡ 
v8
::
PrݔtyClbackInfo
<> &
fo
) {

238 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

239 
	gPrݔtyClbackInfo
<>

240 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

241 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

242 
t_
<
_t
>(

243 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

244 
back
(
ݔty
, 
vue
, 
cbfo
);

247 (*
	gNiveSr
)(

248 
	tv8
::
	tLol
<v8::
	tSg
>

249 , 
	tv8
::
	tLol
<v8::
	tVue
>

250 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<> &);

253 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


255 
PrݔtyGrClbackW
(

256 
v8
::
Lol
<v8::
Name
> 
ݔty


257 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

258 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

259 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

260 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

261 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

262 
t_
<
_t
>(

263 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

264 .
As
<
v8
::
Ex
>()->
Vue
()));

265 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

268 (*
	gNivePrݔtyGr
)

269 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

272 
PrݔtySrClbackW
(

273 
v8
::
Lol
<v8::
Name
> 
ݔty


274 , 
v8
::
Lol
<v8::
Vue
> 
vue


275 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

276 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

277 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

278 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

279 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

280 
t_
<
_t
>(

281 
obj
->
GIlFld
(
kPrݔtySrIndex
)

282 .
As
<
v8
::
Ex
>()->
Vue
()));

283 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
vue
, 
cbfo
);

286 (*
	gNivePrݔtySr
)(

287 
	tv8
::
	tLol
<v8::
	tName
>

288 , 
	tv8
::
	tLol
<v8::
	tVue
>

289 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

292 
PrݔtyEnumClbackW
(

293 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

294 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

295 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

296 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

297 
PrݔtyEnumClback
 
	gback
 =

298 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

299 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

300 .
As
<
v8
::
Ex
>()->
Vue
()));

301 
back
(
cbfo
);

304 (*
	gNivePrݔtyEnum
)

305 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

308 
PrݔtyDClbackW
(

309 
v8
::
Lol
<v8::
Name
> 
ݔty


310 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

311 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

312 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

313 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

314 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

315 
t_
<
_t
>(

316 
obj
->
GIlFld
(
kPrݔtyDIndex
)

317 .
As
<
v8
::
Ex
>()->
Vue
()));

318 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

321 (
	gNivePrݔtyD
)

322 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

325 
PrݔtyQuyClbackW
(

326 
v8
::
Lol
<v8::
Name
> 
ݔty


327 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

328 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

329 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

330 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

331 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

332 
t_
<
_t
>(

333 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

334 .
As
<
v8
::
Ex
>()->
Vue
()));

335 
back
(
ݔty
.
As
<
v8
::
Sg
>(), 
cbfo
);

338 (*
	gNivePrݔtyQuy
)

339 (
	tv8
::
	tLol
<v8::
	tName
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

342 
PrݔtyGrClbackW
(

343 
v8
::
Lol
<v8::
Sg
> 
ݔty


344 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

345 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

346 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

347 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

348 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

349 
t_
<
_t
>(

350 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

351 .
As
<
v8
::
Ex
>()->
Vue
()));

352 
back
(
ݔty
, 
cbfo
);

355 (*
	gNivePrݔtyGr
)

356 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

359 
PrݔtySrClbackW
(

360 
v8
::
Lol
<v8::
Sg
> 
ݔty


361 , 
v8
::
Lol
<v8::
Vue
> 
vue


362 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

363 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

364 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

365 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

366 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

367 
t_
<
_t
>(

368 
obj
->
GIlFld
(
kPrݔtySrIndex
)

369 .
As
<
v8
::
Ex
>()->
Vue
()));

370 
back
(
ݔty
, 
vue
, 
cbfo
);

373 (*
	gNivePrݔtySr
)(

374 
	tv8
::
	tLol
<v8::
	tSg
>

375 , 
	tv8
::
	tLol
<v8::
	tVue
>

376 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

379 
PrݔtyEnumClbackW
(

380 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

381 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

382 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

383 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

384 
PrݔtyEnumClback
 
	gback
 =

385 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

386 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

387 .
As
<
v8
::
Ex
>()->
Vue
()));

388 
back
(
cbfo
);

391 (*
	gNivePrݔtyEnum
)

392 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

395 
PrݔtyDClbackW
(

396 
v8
::
Lol
<v8::
Sg
> 
ݔty


397 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

398 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

399 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

400 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

401 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

402 
t_
<
_t
>(

403 
obj
->
GIlFld
(
kPrݔtyDIndex
)

404 .
As
<
v8
::
Ex
>()->
Vue
()));

405 
back
(
ݔty
, 
cbfo
);

408 (
	gNivePrݔtyD
)

409 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

412 
PrݔtyQuyClbackW
(

413 
v8
::
Lol
<v8::
Sg
> 
ݔty


414 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

415 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

416 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

417 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

418 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

419 
t_
<
_t
>(

420 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

421 .
As
<
v8
::
Ex
>()->
Vue
()));

422 
back
(
ݔty
, 
cbfo
);

425 (*
	gNivePrݔtyQuy
)

426 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

430 
IndexGrClbackW
(

431 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

432 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

433 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

434 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

435 
IndexGrClback
 
	gback
 = 
t_
<IndexGetterCallback>(

436 
t_
<
_t
>(

437 
obj
->
GIlFld
(
kIndexPrݔtyGrIndex
)

438 .
As
<
v8
::
Ex
>()->
Vue
()));

439 
back
(
dex
, 
cbfo
);

442 (*
	gNiveIndexGr
)

443 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

446 
IndexSrClbackW
(

447 
ut32_t
 
dex


448 , 
v8
::
Lol
<v8::
Vue
> 
vue


449 , cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Vue
> &
fo
) {

450 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

451 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

452 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

453 
IndexSrClback
 
	gback
 = 
t_
<IndexSetterCallback>(

454 
t_
<
_t
>(

455 
obj
->
GIlFld
(
kIndexPrݔtySrIndex
)

456 .
As
<
v8
::
Ex
>()->
Vue
()));

457 
back
(
dex
, 
vue
, 
cbfo
);

460 (*
	gNiveIndexSr
)(

461 
	tut32_t


462 , 
	tv8
::
	tLol
<v8::
	tVue
>

463 , cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tVue
> &);

466 
IndexEnumClbackW
(

467 cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Aay
> &
fo
) {

468 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

469 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

470 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

471 
IndexEnumClback
 
	gback
 = 
t_
<IndexEnumeratorCallback>(

472 
t_
<
_t
>(

473 
obj
->
GIlFld
(

474 
kIndexPrݔtyEnumIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

475 
back
(
cbfo
);

478 (*
	gNiveIndexEnum
)

479 (cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tAay
> &);

482 
IndexDClbackW
(

483 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Boޗn
> &
fo
) {

484 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

485 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

486 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

487 
IndexDClback
 
	gback
 = 
t_
<IndexDeleterCallback>(

488 
t_
<
_t
>(

489 
obj
->
GIlFld
(
kIndexPrݔtyDIndex
)

490 .
As
<
v8
::
Ex
>()->
Vue
()));

491 
back
(
dex
, 
cbfo
);

494 (*
	gNiveIndexD
)

495 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tBoޗn
> &);

498 
IndexQuyClbackW
(

499 
ut32_t
 
dex
, cڡ 
v8
::
PrݔtyClbackInfo
<v8::
Ieg
> &
fo
) {

500 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

501 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

502 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

503 
IndexQuyClback
 
	gback
 = 
t_
<IndexQueryCallback>(

504 
t_
<
_t
>(

505 
obj
->
GIlFld
(
kIndexPrݔtyQuyIndex
)

506 .
As
<
v8
::
Ex
>()->
Vue
()));

507 
back
(
dex
, 
cbfo
);

510 (*
	gNiveIndexQuy
)

511 (
	tut32_t
, cڡ 
	tv8
::
	tPrݔtyClbackInfo
<v8::
	tIeg
> &);

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_callbacks_pre_12_inl.h

9 #ide
NAN_CALLBACKS_PRE_12_INL_H_


10 
	#NAN_CALLBACKS_PRE_12_INL_H_


	)

12 
mea
 
	gimp
 {

13 
	gme
<
tyme
 
	gT
> 
ass
 
	gRuVueImp
;

16 
	gme
<
tyme
 
	gT
>

17 as
	cRuVue
 {

18 
	mv8
::
Isީe
 *
isީe_
;

19 
	mv8
::
Psit
<
T
> *
vue_
;

20 
nd
 
ass
 
	mimp
::
RuVueImp
<
T
>;

22 
	mpublic
:

23 
me
 <
ass
 
S
>

24 
exic
 
le
 
RuVue
(
v8
::
Isީe
 *
isީe
, v8::
Psit
<
S
> *
p
) :

25 
isީe_
(
isީe
), 
	$vue_
(
p
) {}

26 
me
 <
ass
 
S
>

27 
exic
 
le
 
	`RuVue
(cڡ 
RuVue
<
S
>& 
th
)

28 : 
	`isީe_
(
th
.
isީe_
), 
	$vue_
(
th
.
vue_
) {

29 
	`TYPE_CHECK
(
T
, 
S
);

30 
	}
}

33 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
v8
::
Lol
<
S
> &
hd
) {

34 
TYPE_CHECK
(
T
, 
S
);

35 
	gvue_
->
Dio
();

36 *
	gvue_
 = 
v8
::
Psit
<
T
>::
New
(
hd
);

39 
	gme
 <
tyme
 
	gS
> 
le
 
S
(cڡ 
Glob
<
S
> &
hd
) {

40 
TYPE_CHECK
(
T
, 
S
);

41 
	gvue_
->
Dio
();

42 *
	gvue_
 = 
v8
::
Psit
<
T
>::
New
(
hd
.
rsit
);

43 
	gcڡ_
<
	gGlob
<
	gS
> &>(
	ghd
).
Ret
();

47 
le
 
	$S
(
bo
 
vue
) {

48 
v8
::
HdSce
 
sce
;

50 
	`TYPE_CHECK
(
T
, 
v8
::
Boޗn
);

51 
vue_
->
	`Dio
();

52 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Boޗn
::New(
vue
));

53 
	}
}

55 
le
 
	$S
(
i
) {

56 
v8
::
HdSce
 
sce
;

58 
	`TYPE_CHECK
(
T
, 
v8
::
Numb
);

59 
vue_
->
	`Dio
();

60 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Numb
::New(
i
));

61 
	}
}

63 
le
 
	$S
(
t32_t
 
i
) {

64 
v8
::
HdSce
 
sce
;

66 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

67 
vue_
->
	`Dio
();

68 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
I32
::New(
i
));

69 
	}
}

71 
le
 
	$S
(
ut32_t
 
i
) {

72 
v8
::
HdSce
 
sce
;

74 
	`TYPE_CHECK
(
T
, 
v8
::
Ieg
);

75 
vue_
->
	`Dio
();

76 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Ut32
::
	`NewFromUnsigd
(
i
));

77 
	}
}

80 
le
 
	$SNu
() {

81 
v8
::
HdSce
 
sce
;

83 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

84 
vue_
->
	`Dio
();

85 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
	`Nu
());

86 
	}
}

88 
le
 
	$SUndefed
() {

89 
v8
::
HdSce
 
sce
;

91 
	`TYPE_CHECK
(
T
, 
v8
::
Primive
);

92 
vue_
->
	`Dio
();

93 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
	`Undefed
());

94 
	}
}

96 
le
 
	$SEmySg
() {

97 
v8
::
HdSce
 
sce
;

99 
	`TYPE_CHECK
(
T
, 
v8
::
Sg
);

100 
vue_
->
	`Dio
();

101 *
vue_
 = 
v8
::
Psit
<
T
>::
	`New
(v8::
Sg
::
	`Emy
());

102 
	}
}

105 
le
 
	gv8
::
Isީe
 *
	$GIsީe
() const {

106  
isީe_
;

107 
	}
}

110 
	gme
<
tyme
 
	gS
>

111 
le
 
	$S
(
S
 *
whev
{ 
	`TYPE_CHECK
(S*, 
v8
::
Primive
); 
	}
}

114 
	gme
<
tyme
 
	gT
>

115 as
	cFuniClbackInfo
 {

116 cڡ 
	mv8
::
Argumts
 &
gs_
;

117 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

118 
	mRuVue
<
	mT
> 
	mtu_vue_
;

119 
	mv8
::
Psit
<
T
> 
tv_
;

121 
	mpublic
:

122 
exic
 
le
 
FuniClbackInfo
(

123 cڡ 
v8
::
Argumts
 &
gs


124 , 
v8
::
Lol
<v8::
Vue
> 
da
) :

125 
gs_
(
gs
)

126 , 
da_
(
da
)

127 , 
tu_vue_
(
gs
.
GIsީe
(), &
tv_
)

128 , 
tv_
(
v8
::
Psit
<
T
>::
New
(v8::
	$Undefed
())) {}

130 
le
 ~
	$FuniClbackInfo
() {

131 
tv_
.
	`Dio
();

132 
tv_
.
	`Cˬ
();

133 
	}
}

135 
le
 
	gRuVue
<
	gT
> 
	$GRuVue
() const {

136  
RuVue
<
T
>(
tu_vue_
);

137 
	}
}

139 
le
 
	gv8
::
Lol
<
v8
::
Funi
> 
	$Ce
(cڡ {  
gs_
.
	`Ce
(); 
	}
}

140 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

141 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
gs_
.
	`Hd
(); 
	}
}

142 
le
 
bo
 
	$IsCڡruCl
(cڡ {  
gs_
.
	`IsCڡruCl
(); 
	}
}

143 
le
 
	$Lgth
(cڡ {  
gs_
.
	`Lgth
(); 
	}
}

144 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
ݔ
[](
i
cڡ {  
gs_
[i]; }

145 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
gs_
.
	`This
(); 
	}
}

146 
le
 
	gv8
::
Isީe
 *
	$GIsީe
(cڡ {  
gs_
.
	`GIsީe
(); 
	}
}

149 
	geed
:

150 cڡ 
kHdIndex
 = 0;

151 cڡ 
	gkIsީeIndex
 = 1;

152 cڡ 
	gkRuVueDeuVueIndex
 = 2;

153 cڡ 
	gkRuVueIndex
 = 3;

154 cڡ 
	gkDaIndex
 = 4;

155 cڡ 
	gkCeIndex
 = 5;

156 cڡ 
	gkCڋxtSaveIndex
 = 6;

157 cڡ 
	gkArgsLgth
 = 7;

159 
	give
:

160 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
FuniClbackInfo
)

163 
	gme
<
tyme
 
	gT
>

164 as
	cPrݔtyClbackInfoBa
 {

165 cڡ 
	mv8
::
AcssInfo
 &
fo_
;

166 cڡ 
	mv8
::
Lol
<
v8
::
Vue
> 
da_
;

168 
	mpublic
:

169 
exic
 
le
 
PrݔtyClbackInfoBa
(

170 cڡ 
v8
::
AcssInfo
 &
fo


171 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

172 
fo_
(
fo
)

173 , 
	$da_
(
da
) {}

175 
le
 
v8
::
Isީe
* 
	$GIsީe
(cڡ {  
fo_
.
	`GIsީe
(); 
	}
}

176 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
	$Da
(cڡ {  
da_
; 
	}
}

177 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$This
(cڡ {  
fo_
.
	`This
(); 
	}
}

178 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$Hd
(cڡ {  
fo_
.
	`Hd
(); 
	}
}

180 
	geed
:

181 cڡ 
kHdIndex
 = 0;

182 cڡ 
	gkIsީeIndex
 = 1;

183 cڡ 
	gkRuVueDeuVueIndex
 = 2;

184 cڡ 
	gkRuVueIndex
 = 3;

185 cڡ 
	gkDaIndex
 = 4;

186 cڡ 
	gkThisIndex
 = 5;

187 cڡ 
	gkArgsLgth
 = 6;

189 
	give
:

190 
NAN_DISALLOW_ASSIGN_COPY_MOVE
(
PrݔtyClbackInfoBa
)

193 
	gme
<
tyme
 
	gT
>

194 
ass
 
	gPrݔtyClbackInfo
 : 
public
 
PrݔtyClbackInfoBa
<
T
> {

195 
RuVue
<
T
> 
tu_vue_
;

196 
	gv8
::
Psit
<
T
> 
tv_
;

198 
	gpublic
:

199 
exic
 
le
 
PrݔtyClbackInfo
(

200 cڡ 
v8
::
AcssInfo
 &
fo


201 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

202 
PrݔtyClbackInfoBa
<
T
>(
fo
, 
	gda
)

203 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

204 , 
tv_
(
v8
::
Psit
<
T
>::
New
(v8::
Undefed
())) {}

206 
le
 ~
PrݔtyClbackInfo
() {

207 
tv_
.
Dio
();

208 
	gtv_
.
Cˬ
();

211 
le
 
	gRuVue
<
	gT
> 
GRuVue
(cڡ {  
	gtu_vue_
; }

214 
	gme
<>

215 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
> :

216 
public
 
PrݔtyClbackInfoBa
<
v8
::
Aay
> {

217 
RuVue
<
v8
::
Aay
> 
tu_vue_
;

218 
	gv8
::
Psit
<
v8
::
Aay
> 
tv_
;

220 
	gpublic
:

221 
exic
 
le
 
PrݔtyClbackInfo
(

222 cڡ 
v8
::
AcssInfo
 &
fo


223 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

224 
PrݔtyClbackInfoBa
<
v8
::
Aay
>(
fo
, 
	gda
)

225 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

226 , 
tv_
(
v8
::
Psit
<v8::
Aay
>::
New
(v8::
Lol
<v8::Array>())) {}

228 
le
 ~
PrݔtyClbackInfo
() {

229 
tv_
.
Dio
();

230 
	gtv_
.
Cˬ
();

233 
le
 
	gRuVue
<
	gv8
::
Aay
> 
GRuVue
() const {

234  
tu_vue_
;

238 
	gme
<>

239 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
> :

240 
public
 
PrݔtyClbackInfoBa
<
v8
::
Boޗn
> {

241 
RuVue
<
v8
::
Boޗn
> 
tu_vue_
;

242 
	gv8
::
Psit
<
v8
::
Boޗn
> 
tv_
;

244 
	gpublic
:

245 
exic
 
le
 
PrݔtyClbackInfo
(

246 cڡ 
v8
::
AcssInfo
 &
fo


247 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

248 
PrݔtyClbackInfoBa
<
v8
::
Boޗn
>(
fo
, 
	gda
)

249 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

250 , 
tv_
(
v8
::
Psit
<v8::
Boޗn
>::
New
(v8::
Lol
<v8::Boolean>())) {}

252 
le
 ~
PrݔtyClbackInfo
() {

253 
tv_
.
Dio
();

254 
	gtv_
.
Cˬ
();

257 
le
 
	gRuVue
<
	gv8
::
Boޗn
> 
GRuVue
() const {

258  
tu_vue_
;

262 
	gme
<>

263 
ass
 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
> :

264 
public
 
PrݔtyClbackInfoBa
<
v8
::
Ieg
> {

265 
RuVue
<
v8
::
Ieg
> 
tu_vue_
;

266 
	gv8
::
Psit
<
v8
::
Ieg
> 
tv_
;

268 
	gpublic
:

269 
exic
 
le
 
PrݔtyClbackInfo
(

270 cڡ 
v8
::
AcssInfo
 &
fo


271 , cڡ 
v8
::
Lol
<v8::
Vue
> 
da
) :

272 
PrݔtyClbackInfoBa
<
v8
::
Ieg
>(
fo
, 
	gda
)

273 , 
tu_vue_
(
fo
.
GIsީe
(), &
tv_
)

274 , 
tv_
(
v8
::
Psit
<v8::
Ieg
>::
New
(v8::
Lol
<v8::Integer>())) {}

276 
le
 ~
PrݔtyClbackInfo
() {

277 
tv_
.
Dio
();

278 
	gtv_
.
Cˬ
();

281 
le
 
	gRuVue
<
	gv8
::
Ieg
> 
GRuVue
() const {

282  
tu_vue_
;

286 
mea
 
	gimp
 {

287 
	gme
<
tyme
 
	gT
>

288 
ass
 
	gRuVueImp
 : 
public
 
RuVue
<
T
> {

289 
public
:

290 
exic
 
RuVueImp
(
RuVue
<
T
> 
th
) :

291 
RuVue
<
T
>(
th
) {}

292 
le
 
v8
::
Hd
<
T
> 
Vue
() {

293  *
RuVue
<
T
>::
vue_
;

298 
	gv8
::
Hd
<
v8
::
Vue
> 
FuniClbackW
(cڡ v8::
Argumts
 &
gs
) {

299 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
gs
.
Da
().
As
<v8::Object>();

300 
FuniClback
 
	gback
 = 
t_
<FunctionCallback>(

301 
t_
<
_t
>(

302 
obj
->
GIlFld
(
kFuniIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

303 
	gFuniClbackInfo
<
	gv8
::
Vue
>

304 
cbfo
(
gs
, 
obj
->
GIlFld
(
kDaIndex
));

305 
back
(
cbfo
);

306  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

309 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveFuni
)(cڡ v8::
	tArgumts
 &);

312 
	gv8
::
Hd
<
v8
::
Vue
> 
GrClbackW
(

313 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

314 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

315 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

316 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

317 
GrClback
 
	gback
 = 
t_
<GetterCallback>(

318 
t_
<
_t
>(

319 
obj
->
GIlFld
(
kGrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

320 
back
(
ݔty
, 
cbfo
);

321  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

324 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveGr
)

325 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

328 
SrClbackW
(

329 
v8
::
Lol
<v8::
Sg
> 
ݔty


330 , 
v8
::
Lol
<v8::
Vue
> 
vue


331 , cڡ 
v8
::
AcssInfo
 &
fo
) {

332 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

333 
	gPrݔtyClbackInfo
<>

334 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

335 
SrClback
 
	gback
 = 
t_
<SetterCallback>(

336 
t_
<
_t
>(

337 
obj
->
GIlFld
(
kSrIndex
).
As
<
v8
::
Ex
>()->
Vue
()));

338 
back
(
ݔty
, 
vue
, 
cbfo
);

341 (*
	gNiveSr
)

342 (
	tv8
::
	tLol
<v8::
	tSg
>, v8::Lol<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

345 
	gv8
::
Hd
<
v8
::
Vue
> 
PrݔtyGrClbackW
(

346 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

347 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

348 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

349 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

350 
PrݔtyGrClback
 
	gback
 = 
t_
<PropertyGetterCallback>(

351 
t_
<
_t
>(

352 
obj
->
GIlFld
(
kPrݔtyGrIndex
)

353 .
As
<
v8
::
Ex
>()->
Vue
()));

354 
back
(
ݔty
, 
cbfo
);

355  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

358 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNivePrݔtyGr
)

359 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

362 
	gv8
::
Hd
<
v8
::
Vue
> 
PrݔtySrClbackW
(

363 
v8
::
Lol
<v8::
Sg
> 
ݔty


364 , 
v8
::
Lol
<v8::
Vue
> 
vue


365 , cڡ 
v8
::
AcssInfo
 &
fo
) {

366 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

367 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

368 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

369 
PrݔtySrClback
 
	gback
 = 
t_
<PropertySetterCallback>(

370 
t_
<
_t
>(

371 
obj
->
GIlFld
(
kPrݔtySrIndex
)

372 .
As
<
v8
::
Ex
>()->
Vue
()));

373 
back
(
ݔty
, 
vue
, 
cbfo
);

374  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

377 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNivePrݔtySr
)

378 (
	tv8
::
	tLol
<v8::
	tSg
>, v8::Lol<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

381 
	gv8
::
Hd
<
v8
::
Aay
> 
PrݔtyEnumClbackW
(

382 cڡ 
v8
::
AcssInfo
 &
fo
) {

383 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

384 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

385 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

386 
PrݔtyEnumClback
 
	gback
 =

387 
t_
<
PrݔtyEnumClback
>et_<
_t
>(

388 
obj
->
GIlFld
(
kPrݔtyEnumIndex
)

389 .
As
<
v8
::
Ex
>()->
Vue
()));

390 
back
(
cbfo
);

391  
	gRuVueImp
<
	gv8
::
Aay
>(
cbfo
.
GRuVue
()).
Vue
();

394 
	gv8
::
	tHd
<
	tv8
::
	tAay
> (*
	tNivePrݔtyEnum
)

395 (cڡ 
	tv8
::
	tAcssInfo
 &);

398 
	gv8
::
Hd
<
v8
::
Boޗn
> 
PrݔtyDClbackW
(

399 
v8
::
Lol
<v8::
Sg
> 
ݔty


400 , cڡ 
v8
::
AcssInfo
 &
fo
) {

401 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

402 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

403 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

404 
PrݔtyDClback
 
	gback
 = 
t_
<PropertyDeleterCallback>(

405 
t_
<
_t
>(

406 
obj
->
GIlFld
(
kPrݔtyDIndex
)

407 .
As
<
v8
::
Ex
>()->
Vue
()));

408 
back
(
ݔty
, 
cbfo
);

409  
	gRuVueImp
<
	gv8
::
Boޗn
>(
cbfo
.
GRuVue
()).
Vue
();

412 
	gv8
::
	tHd
<
	tv8
::
	tBoޗn
> (
	tNivePrݔtyD
)

413 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

416 
	gv8
::
Hd
<
v8
::
Ieg
> 
PrݔtyQuyClbackW
(

417 
v8
::
Lol
<v8::
Sg
> 
ݔty
, cڡ v8::
AcssInfo
 &
fo
) {

418 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

419 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

420 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

421 
PrݔtyQuyClback
 
	gback
 = 
t_
<PropertyQueryCallback>(

422 
t_
<
_t
>(

423 
obj
->
GIlFld
(
kPrݔtyQuyIndex
)

424 .
As
<
v8
::
Ex
>()->
Vue
()));

425 
back
(
ݔty
, 
cbfo
);

426  
	gRuVueImp
<
	gv8
::
Ieg
>(
cbfo
.
GRuVue
()).
Vue
();

429 
	gv8
::
	tHd
<
	tv8
::
	tIeg
> (*
	tNivePrݔtyQuy
)

430 (
	tv8
::
	tLol
<v8::
	tSg
>, cڡ v8::
	tAcssInfo
 &);

433 
	gv8
::
Hd
<
v8
::
Vue
> 
IndexGrClbackW
(

434 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

435 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

436 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

437 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

438 
IndexGrClback
 
	gback
 = 
t_
<IndexGetterCallback>(

439 
t_
<
_t
>(

440 
obj
->
GIlFld
(
kIndexPrݔtyGrIndex
)

441 .
As
<
v8
::
Ex
>()->
Vue
()));

442 
back
(
dex
, 
cbfo
);

443  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

446 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveIndexGr
)

447 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

450 
	gv8
::
Hd
<
v8
::
Vue
> 
IndexSrClbackW
(

451 
ut32_t
 
dex


452 , 
v8
::
Lol
<v8::
Vue
> 
vue


453 , cڡ 
v8
::
AcssInfo
 &
fo
) {

454 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

455 
	gPrݔtyClbackInfo
<
	gv8
::
Vue
>

456 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

457 
IndexSrClback
 
	gback
 = 
t_
<IndexSetterCallback>(

458 
t_
<
_t
>(

459 
obj
->
GIlFld
(
kIndexPrݔtySrIndex
)

460 .
As
<
v8
::
Ex
>()->
Vue
()));

461 
back
(
dex
, 
vue
, 
cbfo
);

462  
	gRuVueImp
<
	gv8
::
Vue
>(
cbfo
.
GRuVue
()).Value();

465 
	gv8
::
	tHd
<
	tv8
::
	tVue
> (*
	tNiveIndexSr
)

466 (
	tut32_t
, 
	tv8
::
	tLol
<v8::
	tVue
>, cڡ v8::
	tAcssInfo
 &);

469 
	gv8
::
Hd
<
v8
::
Aay
> 
IndexEnumClbackW
(

470 cڡ 
v8
::
AcssInfo
 &
fo
) {

471 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

472 
	gPrݔtyClbackInfo
<
	gv8
::
Aay
>

473 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

474 
IndexEnumClback
 
	gback
 = 
t_
<IndexEnumeratorCallback>(

475 
t_
<
_t
>(

476 
obj
->
GIlFld
(
kIndexPrݔtyEnumIndex
)

477 .
As
<
v8
::
Ex
>()->
Vue
()));

478 
back
(
cbfo
);

479  
	gRuVueImp
<
	gv8
::
Aay
>(
cbfo
.
GRuVue
()).
Vue
();

482 
	gv8
::
	tHd
<
	tv8
::
	tAay
> (*
	tNiveIndexEnum
)

483 (cڡ 
	tv8
::
	tAcssInfo
 &);

486 
	gv8
::
Hd
<
v8
::
Boޗn
> 
IndexDClbackW
(

487 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

488 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

489 
	gPrݔtyClbackInfo
<
	gv8
::
Boޗn
>

490 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

491 
IndexDClback
 
	gback
 = 
t_
<IndexDeleterCallback>(

492 
t_
<
_t
>(

493 
obj
->
GIlFld
(
kIndexPrݔtyDIndex
)

494 .
As
<
v8
::
Ex
>()->
Vue
()));

495 
back
(
dex
, 
cbfo
);

496  
	gRuVueImp
<
	gv8
::
Boޗn
>(
cbfo
.
GRuVue
()).
Vue
();

499 
	gv8
::
	tHd
<
	tv8
::
	tBoޗn
> (*
	tNiveIndexD
)

500 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

503 
	gv8
::
Hd
<
v8
::
Ieg
> 
IndexQuyClbackW
(

504 
ut32_t
 
dex
, cڡ 
v8
::
AcssInfo
 &
fo
) {

505 
v8
::
Lol
<v8::
Obje
> 
obj
 = 
fo
.
Da
().
As
<v8::Object>();

506 
	gPrݔtyClbackInfo
<
	gv8
::
Ieg
>

507 
cbfo
(
fo
, 
obj
->
GIlFld
(
kDaIndex
));

508 
IndexQuyClback
 
	gback
 = 
t_
<IndexQueryCallback>(

509 
t_
<
_t
>(

510 
obj
->
GIlFld
(
kIndexPrݔtyQuyIndex
)

511 .
As
<
v8
::
Ex
>()->
Vue
()));

512 
back
(
dex
, 
cbfo
);

513  
	gRuVueImp
<
	gv8
::
Ieg
>(
cbfo
.
GRuVue
()).
Vue
();

516 
	gv8
::
	tHd
<
	tv8
::
	tIeg
> (*
	tNiveIndexQuy
)

517 (
	tut32_t
, cڡ 
	tv8
::
	tAcssInfo
 &);

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_converters.h

9 #ide
NAN_CONVERTERS_H_


10 
	#NAN_CONVERTERS_H_


	)

12 
mea
 
	gimp
 {

13 
	gme
<
tyme
 
	gT
> 
	sToFayBa
 {

14 
	gMaybeLol
<
	tT
> 
	ttu_t
;

16 
	gme
<
tyme
 
	gT
> 
	sVueFayBa
 { 
	gMaybe
<
	tT
> 
	ttu_t
; };

18 
	gme
<
tyme
 
	gT
> 
	gToFay
;

20 
	gme
<>

21 
	gToFay
<
	gv8
::
Funi
> : 
ToFayBa
<
v8
::Function> {

22 
le
 
tu_t
 
cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) {

23 i(
v
.
IsEmy
(|| !v->
IsFuni
() 
MaybeLol
<
v8
::
Funi
>();

24  
	gMaybeLol
<
	gv8
::
Funi
>(
v
.
As
<
v8
::Function>());

28 
	#X
(
TYPE
) \

29 
me
<> \

30 
ToFay
<
v8
::
TYPE
> : 
ToFayBa
<v8::TYPE> { \

31 
le
 
tu_t
 
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
); \

32 };

	)

34 
X
(
Boޗn
)

35 
X
(
Numb
)

36 
X
(
Sg
)

37 
X
(
Obje
)

38 
X
(
Ieg
)

39 
X
(
Ut32
)

40 
X
(
I32
)

42 #unde
X


44 
	#X
(
TYPE
) \

45 
me
<> \

46 
ToFay
<
TYPE
> : 
VueFayBa
<TYPE> { \

47 
le
 
tu_t
 
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
); \

48 };

	)

50 
X
(
bo
)

51 
X
()

52 
X
(
t64_t
)

53 
X
(
ut32_t
)

54 
X
(
t32_t
)

56 #unde
X


59 
	gme
<
tyme
 
	gT
>

60 
le


61 
tyme
 
	gimp
::
ToFay
<
T
>::
tu_t
 
To
(
v8
::
Lol
<v8::
Vue
> 
v
) {

62  
imp
::
ToFay
<
T
>::
cvt
(
v
);

65 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

66 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

67 
	~"n_cvrs_43_l.h
"

69 
	~"n_cvrs_e_43_l.h
"

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_converters_43_inl.h

9 #ide
NAN_CONVERTERS_43_INL_H_


10 
	#NAN_CONVERTERS_43_INL_H_


	)

12 
	#X
(
TYPE
) \

13 
imp
::
ToFay
<
v8
::
TYPE
>::
tu_t
 \

14 
imp
::
ToFay
<
v8
::
TYPE
>::
	`cvt
(v8::
Lol
<v8::
Vue
> 
v
) { \

15 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
(); \

16 
v8
::
EsbHdSce
 
	`sce
(
isީe
); \

17  
sce
.
	`Es
( \

18 
v
->
To
 ## 
	`TYPE
(
isީe
->
	`GCutCڋxt
()) \

19 .
	`FromMaybe
(
v8
::
Lol
<v8::
TYPE
>())); \

20 }

	)

22 
	$X
(
Numb
)

23 
	$X
(
Sg
)

24 
	$X
(
Obje
)

25 
	$X
(
Ieg
)

26 
	$X
(
Ut32
)

27 
	$X
(
I32
)

29 #i
V8_MAJOR_VERSION
 < 7 || (V8_MAJOR_VERSION =7 && 
V8_MINOR_VERSION
 == 0)

30 
	$X
(
Boޗn
)

32 
imp
::
ToFay
<
v8
::
Boޗn
>::
tu_t
 \

33 
imp
::
ToFay
<
v8
::
Boޗn
>::
	`cvt
(v8::
Lol
<v8::
Vue
> 
v
) { \

34 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
(); \

35 
v8
::
EsbHdSce
 
	`sce
(
isީe
); \

36  
sce
.
	`Es
(
v
->
	`ToBoޗn
(
isީe
)); \

37 
	}
}

40 #unde
X


42 
	#X
(
TYPE
, 
NAME
) \

43 
imp
::
ToFay
<
TYPE
>::
tu_t
 \

44 
imp
::
ToFay
<
TYPE
>::
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) { \

45 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
(); \

46 
v8
::
HdSce
 
	`sce
(
isީe
); \

47  
v
->
NAME
 ## 
	`Vue
(
isީe
->
	`GCutCڋxt
()); \

48 }

	)

50 
	$X
(, 
Numb
)

51 
	$X
(
t64_t
, 
Ieg
)

52 
	$X
(
ut32_t
, 
Ut32
)

53 
	$X
(
t32_t
, 
I32
)

55 #i
V8_MAJOR_VERSION
 < 7 || (V8_MAJOR_VERSION =7 && 
V8_MINOR_VERSION
 == 0)

56 
	$X
(
bo
, 
Boޗn
)

58 
imp
::
ToFay
<
bo
>::
tu_t
 \

59 
imp
::
ToFay
<
bo
>::
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) { \

60 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
	`GCut
(); \

61 
v8
::
HdSce
 
	`sce
(
isީe
); \

62  
Ju
<
bo
>(
v
->
	`BoޗnVue
(
isީe
)); \

63 
	}
}

66 #unde
X


	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_converters_pre_43_inl.h

9 #ide
NAN_CONVERTERS_PRE_43_INL_H_


10 
	#NAN_CONVERTERS_PRE_43_INL_H_


	)

12 
	#X
(
TYPE
) \

13 
imp
::
ToFay
<
v8
::
TYPE
>::
tu_t
 \

14 
imp
::
ToFay
<
v8
::
TYPE
>::
	`cvt
(v8::
Lol
<v8::
Vue
> 
v
) { \

15  
v
->
To
 ## 
	`TYPE
(); \

16 }

	)

18 
	$X
(
Boޗn
)

19 
	$X
(
Numb
)

20 
	$X
(
Sg
)

21 
	$X
(
Obje
)

22 
	$X
(
Ieg
)

23 
	$X
(
Ut32
)

24 
	$X
(
I32
)

26 #unde
X


28 
	#X
(
TYPE
, 
NAME
) \

29 
imp
::
ToFay
<
TYPE
>::
tu_t
 \

30 
imp
::
ToFay
<
TYPE
>::
	`cvt
(
v8
::
Lol
<v8::
Vue
> 
v
) { \

31  
	`Ju
(
v
->
NAME
 ## 
	`Vue
()); \

32 
	}

	)
}

34 
	$X
(
bo
, 
Boޗn
)

35 
	$X
(, 
Numb
)

36 
	$X
(
t64_t
, 
Ieg
)

37 
	$X
(
ut32_t
, 
Ut32
)

38 
	$X
(
t32_t
, 
I32
)

40 #unde
X


	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_define_own_property_helper.h

9 #ide
NAN_DEFINE_OWN_PROPERTY_HELPER_H_


10 
	#NAN_DEFINE_OWN_PROPERTY_HELPER_H_


	)

12 
mea
 
	gimp
 {

14 
le
 
	gMaybe
<
	gbo
> 
DefeOwnPrݔtyHr
(

15 
v8
::
PrݔtyAribu
 
cut


16 , 
v8
::
Hd
<v8::
Obje
> 
obj


17 , 
v8
::
Hd
<v8::
Sg
> 
key


18 , 
v8
::
Hd
<v8::
Vue
> 
vue


19 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

20  !(
cut
 & 
v8
::
DtDe
) ||

21 (!(
cut
 & 
v8
::
RdOy
) &&

22 !((
ibs
 ^ 
cut
& ~
v8
::
RdOy
))

23 ? 
Ju
<
bo
>(
obj
->
FS
(
key
, 
vue
, 
ibs
))

24 : 
Nhg
<
bo
>();

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_implementation_12_inl.h

9 #ide
NAN_IMPLEMENTATION_12_INL_H_


10 
	#NAN_IMPLEMENTATION_12_INL_H_


	)

15 
mea
 
	gimp
 {

19 
	gFay
<
	gv8
::
Aay
>::
tu_t


20 
Fay
<
v8
::
Aay
>::
New
() {

21  
v8
::
Aay
::
New
(v8::
Isީe
::
GCut
());

24 
	gFay
<
	gv8
::
Aay
>::
tu_t


25 
Fay
<
v8
::
Aay
>::
New
(
ngth
) {

26  
v8
::
Aay
::
New
(v8::
Isީe
::
GCut
(), 
ngth
);

31 
	gFay
<
	gv8
::
Boޗn
>::
tu_t


32 
Fay
<
v8
::
Boޗn
>::
New
(
bo
 
vue
) {

33  
v8
::
Boޗn
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

38 
	gFay
<
	gv8
::
BoޗnObje
>::
tu_t


39 
Fay
<
v8
::
BoޗnObje
>::
New
(
bo
 
vue
) {

40 #i(
NODE_MODULE_VERSION
 >
NODE_6_0_MODULE_VERSION
)

41  
v8
::
BoޗnObje
::
New
(

42 
v8
::
Isީe
::
GCut
(), 
vue
).
	gAs
<
	gv8
::
BoޗnObje
>();

44  
	gv8
::
BoޗnObje
::
New
(
vue
).
As
<
v8
::BooleanObject>();

50 
	gFay
<
	gv8
::
Cڋxt
>::
tu_t


51 
Fay
<
v8
::
Cڋxt
>::
New
v8::
ExnsiCfiguti
* 
exnsis


52 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm


53 , 
v8
::
Lol
<v8::
Vue
> 
obj
) {

54  
v8
::
Cڋxt
::
New
(v8::
Isީe
::
GCut
(), 
exnsis
, 
tm
, 
obj
);

59 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

60 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

61 
Fay
<
v8
::
De
>::
tu_t


62 
Fay
<
v8
::
De
>::
New
(
vue
) {

63 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

64 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

65  
	gsce
.
Es
(
v8
::
De
::
New
(
isީe
->
GCutCڋxt
(), 
vue
)

66 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()).
As
<v8::
De
>());

69 
	gFay
<
	gv8
::
De
>::
tu_t


70 
Fay
<
v8
::
De
>::
New
(
vue
) {

71  
v8
::
De
::
New
(v8::
Isީe
::
GCut
(), 
vue
).
	gAs
<
	gv8
::Date>();

77 
	gFay
<
	gv8
::
Ex
>::
tu_t


78 
Fay
<
v8
::
Ex
>::
New
(* 
vue
) {

79  
v8
::
Ex
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

84 
	gFay
<
	gv8
::
Funi
>::
tu_t


85 
Fay
<
v8
::
Funi
>::
New

FuniClback
 
back


86 , 
v8
::
Lol
<v8::
Vue
> 
da
) {

87 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

88 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

89 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
(
isީe
);

90 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

91 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
l
).
ToLolChecked
();

93 
	gobj
->
SIlFld
(

94 
imp
::
kFuniIndex


95 , 
v8
::
Ex
::
New
(
isީe
, 
t_
<*>(
back
)));

97 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
isީe
, 
da
);

99 i(!
	gv
.
IsEmy
()) {

100 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

103 #i
NODE_MAJOR_VERSION
 >= 10

104 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
cڋxt
 = 
isީe
->
GCutCڋxt
();

105 
	gv8
::
Lol
<
v8
::
Funi
> 
funi
 =

106 
v8
::
Funi
::
New
(
cڋxt
, 
imp
::
FuniClbackW
, 
obj
)

107 .
ToLolChecked
();

109 
	gv8
::
Lol
<
v8
::
Funi
> 
funi
 =

110 
v8
::
Funi
::
New
(
isީe
, 
imp
::
FuniClbackW
, 
obj
);

113  
	gsce
.
Es
(
funi
);

118 
	gFay
<
	gv8
::
FuniTeme
>::
tu_t


119 
Fay
<
v8
::
FuniTeme
>::
New

FuniClback
 
back


120 , 
v8
::
Lol
<v8::
Vue
> 
da


121 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
) {

122 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

123 i(
	gback
) {

124 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

125 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
(
isީe
);

126 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

127 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
NewIn
(
l
).
ToLolChecked
();

129 
	gobj
->
SIlFld
(

130 
imp
::
kFuniIndex


131 , 
v8
::
Ex
::
New
(
isީe
, 
t_
<*>(
back
)));

132 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
isީe
, 
da
);

134 i(!
	gv
.
IsEmy
()) {

135 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

138  
	gsce
.
Es
(
v8
::
FuniTeme
::
New

isީe


139 , 
imp
::
FuniClbackW


140 , 
obj


141 , 
sigtu
));

143  
	gv8
::
FuniTeme
::
New
(
isީe
, 0, 
da
, 
sigtu
);

149 
	gFay
<
	gv8
::
Numb
>::
tu_t


150 
Fay
<
v8
::
Numb
>::
New
(
vue
) {

151  
v8
::
Numb
::
New
(v8::
Isީe
::
GCut
(), 
vue
);

156 
	gFay
<
	gv8
::
NumbObje
>::
tu_t


157 
Fay
<
v8
::
NumbObje
>::
New
(
vue
) {

158  
v8
::
NumbObje
::
New
v8::
Isީe
::
GCut
()

159 , 
vue
).
	gAs
<
	gv8
::
NumbObje
>();

164 
	gme
 <
tyme
 
	gT
>

165 
tyme
 
	gIegFay
<
	gT
>::
tu_t


166 
IegFay
<
T
>::
New
(
t32_t
 
vue
) {

167  
To
<
T
>(T::
New
(
v8
::
Isީe
::
GCut
(), 
vue
));

170 
	gme
 <
tyme
 
	gT
>

171 
tyme
 
	gIegFay
<
	gT
>::
tu_t


172 
IegFay
<
T
>::
New
(
ut32_t
 
vue
) {

173  
To
<
T
>(T::
NewFromUnsigd
(
v8
::
Isީe
::
GCut
(), 
vue
));

176 
	gFay
<
	gv8
::
Ut32
>::
tu_t


177 
Fay
<
v8
::
Ut32
>::
New
(
t32_t
 
vue
) {

178  
To
<
v8
::
Ut32
>(

179 
v8
::
Ut32
::
NewFromUnsigd
(v8::
Isީe
::
GCut
(), 
vue
));

182 
	gFay
<
	gv8
::
Ut32
>::
tu_t


183 
Fay
<
v8
::
Ut32
>::
New
(
ut32_t
 
vue
) {

184  
To
<
v8
::
Ut32
>(

185 
v8
::
Ut32
::
NewFromUnsigd
(v8::
Isީe
::
GCut
(), 
vue
));

190 
	gFay
<
	gv8
::
Obje
>::
tu_t


191 
Fay
<
v8
::
Obje
>::
New
() {

192  
v8
::
Obje
::
New
(v8::
Isީe
::
GCut
());

197 
	gFay
<
	gv8
::
ObjeTeme
>::
tu_t


198 
Fay
<
v8
::
ObjeTeme
>::
New
() {

199  
v8
::
ObjeTeme
::
New
(v8::
Isީe
::
GCut
());

204 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

205 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

206 
Fay
<
v8
::
RegExp
>::
tu_t


207 
Fay
<
v8
::
RegExp
>::
New
(

208 
v8
::
Lol
<v8::
Sg
> 
n


209 , 
v8
::
RegExp
::
Fgs
 
ags
) {

210 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

211 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

212  
	gsce
.
Es
(

213 
v8
::
RegExp
::
New
(
isީe
->
GCutCڋxt
(), 
n
, 
ags
)

214 .
FromMaybe
(
v8
::
Lol
<v8::
RegExp
>()));

217 
	gFay
<
	gv8
::
RegExp
>::
tu_t


218 
Fay
<
v8
::
RegExp
>::
New
(

219 
v8
::
Lol
<v8::
Sg
> 
n


220 , 
v8
::
RegExp
::
Fgs
 
ags
) {

221  
v8
::
RegExp
::
New
(
n
, 
ags
);

227 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

228 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

229 
Fay
<
v8
::
St
>::
tu_t


230 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

231 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

232 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

233 
	gv8
::
StComp
::
Sour
 
c
(
sour
);

234  
	gsce
.
Es
(

235 
v8
::
StComp
::
Compe
(
isީe
->
GCutCڋxt
(), &
c
)

236 .
FromMaybe
(
v8
::
Lol
<v8::
St
>()));

239 
	gFay
<
	gv8
::
St
>::
tu_t


240 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


241 , 
v8
::
StOrig
 cڡ& 
ig
) {

242 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

243 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

244 
	gv8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

245  
	gsce
.
Es
(

246 
v8
::
StComp
::
Compe
(
isީe
->
GCutCڋxt
(), &
c
)

247 .
FromMaybe
(
v8
::
Lol
<v8::
St
>()));

250 
	gFay
<
	gv8
::
St
>::
tu_t


251 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

252 
v8
::
StComp
::
Sour
 
c
(
sour
);

253  
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
c
);

256 
	gFay
<
	gv8
::
St
>::
tu_t


257 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


258 , 
v8
::
StOrig
 cڡ& 
ig
) {

259 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

260  
	gv8
::
StComp
::
Compe
(
v8
::
Isީe
::
GCut
(), &
c
);

266 
	gFay
<
	gv8
::
Sigtu
>::
tu_t


267 
Fay
<
v8
::
Sigtu
>::
New
(Fay<v8::Sigtu>::
FTH
 
iv
) {

268  
v8
::
Sigtu
::
New
(v8::
Isީe
::
GCut
(), 
iv
);

273 
	gFay
<
	gv8
::
Sg
>::
tu_t


274 
Fay
<
v8
::
Sg
>::
New
() {

275  
v8
::
Sg
::
Emy
(v8::
Isީe
::
GCut
());

278 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

279 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

280 
Fay
<
v8
::
Sg
>::
tu_t


281 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

282  
	gv8
::
Sg
::
NewFromUtf8
(

283 
v8
::
Isީe
::
GCut
(), 
vue
, v8::
NewSgTy
::
kNm
, 
ngth
);

286 
	gFay
<
	gv8
::
Sg
>::
tu_t


287 
Fay
<
v8
::
Sg
>::
New
(
d
::
rg
 cڡ& 
vue
) {

288 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

289  
	gv8
::
Sg
::
NewFromUtf8
(
v8
::
Isީe
::
GCut
(),

290 
vue
.
da
(), 
v8
::
NewSgTy
::
kNm
, 
ic_
<>(vue.
size
()));

293 
	gFay
<
	gv8
::
Sg
>::
tu_t


294 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

295  
	gv8
::
Sg
::
NewFromTwoBy
(
v8
::
Isީe
::
GCut
(), 
vue
,

296 
v8
::
NewSgTy
::
kNm
, 
ngth
);

299 
	gFay
<
	gv8
::
Sg
>::
tu_t


300 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

301  
v8
::
Sg
::
NewExTwoBy
(v8::
Isީe
::
GCut
(), 
vue
);

304 
	gFay
<
	gv8
::
Sg
>::
tu_t


305 
Fay
<
v8
::
Sg
>::
New
(
ExOBySgResour
 * 
vue
) {

306  
v8
::
Sg
::
NewExOBy
(v8::
Isީe
::
GCut
(), 
vue
);

309 
	gFay
<
	gv8
::
Sg
>::
tu_t


310 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

311  
	gv8
::
Sg
::
NewFromUtf8
(
v8
::
Isީe
::
GCut
(), 
vue
,

312 
v8
::
Sg
::
kNmSg
, 
ngth
);

315 
	gFay
<
	gv8
::
Sg
>::
tu_t


316 
Fay
<
v8
::
Sg
>::
New
(

317 
d
::
rg
 cڡ& 
vue
) {

318 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

319  
	gv8
::
Sg
::
NewFromUtf8
(
v8
::
Isީe
::
GCut
(), 
vue
.
da
(),

320 
v8
::
Sg
::
kNmSg
,

321 
ic_
<>(
vue
.
size
()));

324 
	gFay
<
	gv8
::
Sg
>::
tu_t


325 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

326  
	gv8
::
Sg
::
NewFromTwoBy
(
v8
::
Isީe
::
GCut
(), 
vue
,

327 
v8
::
Sg
::
kNmSg
, 
ngth
);

330 
	gFay
<
	gv8
::
Sg
>::
tu_t


331 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

332  
v8
::
Sg
::
NewEx
(v8::
Isީe
::
GCut
(), 
vue
);

335 
	gFay
<
	gv8
::
Sg
>::
tu_t


336 
Fay
<
v8
::
Sg
>::
New
(
ExOBySgResour
 * 
vue
) {

337  
v8
::
Sg
::
NewEx
(v8::
Isީe
::
GCut
(), 
vue
);

346 
	gFay
<
	gv8
::
SgObje
>::
tu_t


347 
Fay
<
v8
::
SgObje
>::
New
(v8::
Lol
<v8::
Sg
> 
vue
) {

349 #i
V8_MAJOR_VERSION
 > 7 || (V8_MAJOR_VERSION =7 && 
V8_MINOR_VERSION
 > 0)

350  
v8
::
SgObje
::
New
(v8::
Isީe
::
GCut
(), 
vue
)

351 .
	gAs
<
	gv8
::
SgObje
>();

353 #ifde
_MSC_VER


354 #agm
wng
(
push
)

355 #agm
wng
(
dib
 : 4996)

357 #ifde
__GNUC__


358 #agm
GCC
 
dgnoic
 
push


359 #agm
GCC
 
dgnoic
 
igned
 "-Wdeprecated-declarations"

361  
	gv8
::
SgObje
::
New
(
vue
).
As
<
v8
::StringObject>();

362 #ifde
__GNUC__


363 #agm
GCC
 
dgnoic
 
p


365 #ifde
_MSC_VER


366 #agm
wng
(
p
)

373 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

374 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

375 
Fay
<
v8
::
UnboundSt
>::
tu_t


376 
Fay
<
v8
::
UnboundSt
>::
New
(v8::
Lol
<v8::
Sg
> 
sour
) {

377 
v8
::
StComp
::
Sour
 
c
(
sour
);

378  
	gv8
::
StComp
::
CompeUnboundSt
(

379 
v8
::
Isީe
::
GCut
(), &
c
);

382 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


383 
Fay
<
v8
::
UnboundSt
>::
New
v8::
Lol
<v8::
Sg
> 
sour


384 , 
v8
::
StOrig
 cڡ& 
ig
) {

385 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

386  
	gv8
::
StComp
::
CompeUnboundSt
(

387 
v8
::
Isީe
::
GCut
(), &
c
);

390 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


391 
Fay
<
v8
::
UnboundSt
>::
New
(v8::
Lol
<v8::
Sg
> 
sour
) {

392 
v8
::
StComp
::
Sour
 
c
(
sour
);

393  
	gv8
::
StComp
::
CompeUnbound
(
v8
::
Isީe
::
GCut
(), &
c
);

396 
	gFay
<
	gv8
::
UnboundSt
>::
tu_t


397 
Fay
<
v8
::
UnboundSt
>::
New
v8::
Lol
<v8::
Sg
> 
sour


398 , 
v8
::
StOrig
 cڡ& 
ig
) {

399 
v8
::
StComp
::
Sour
 
c
(
sour
, 
ig
);

400  
	gv8
::
StComp
::
CompeUnbound
(
v8
::
Isީe
::
GCut
(), &
c
);

408 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


409 
	gme
 <
tyme
 
	gT
>

410 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
) {

411  
v8
::
Lol
<
T
>::
New
(v8::
Isީe
::
GCut
(), 
h
);

415 
	gme
 <
tyme
 
	gT
,ym
	gM
>

416 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T, 
M
> cڡ& 
p
) {

417  
	gv8
::
Lol
<
T
>::
New
(
v8
::
Isީe
::
GCut
(), 
p
);

420 
	gme
 <
tyme
 
	gT
,ym
	gM
>

421 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
) {

422  
	gv8
::
Lol
<
T
>::
New
(
v8
::
Isީe
::
GCut
(), 
p
);

425 
	gme
 <
tyme
 
	gT
>

426 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
) {

427  
v8
::
Lol
<
T
>::
New
(v8::
Isީe
::
GCut
(), 
p
);

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_implementation_pre_12_inl.h

9 #ide
NAN_IMPLEMENTATION_PRE_12_INL_H_


10 
	#NAN_IMPLEMENTATION_PRE_12_INL_H_


	)

16 
mea
 
	gimp
 {

20 
	gFay
<
	gv8
::
Aay
>::
tu_t


21 
Fay
<
v8
::
Aay
>::
New
() {

22  
v8
::
Aay
::
New
();

25 
	gFay
<
	gv8
::
Aay
>::
tu_t


26 
Fay
<
v8
::
Aay
>::
New
(
ngth
) {

27  
v8
::
Aay
::
New
(
ngth
);

32 
	gFay
<
	gv8
::
Boޗn
>::
tu_t


33 
Fay
<
v8
::
Boޗn
>::
New
(
bo
 
vue
) {

34  
v8
::
Boޗn
::
New
(
vue
)->
ToBoޗn
();

39 
	gFay
<
	gv8
::
BoޗnObje
>::
tu_t


40 
Fay
<
v8
::
BoޗnObje
>::
New
(
bo
 
vue
) {

41  
v8
::
BoޗnObje
::
New
(
vue
).
As
<v8::BooleanObject>();

46 
	gFay
<
	gv8
::
Cڋxt
>::
tu_t


47 
Fay
<
v8
::
Cڋxt
>::
New
v8::
ExnsiCfiguti
* 
exnsis


48 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm


49 , 
v8
::
Lol
<v8::
Vue
> 
obj
) {

50 
v8
::
Psit
<v8::
Cڋxt
> 
x
 = v8::Cڋxt::
New
(
exnsis
, 
tm
, 
obj
);

51 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
lx
 = v8::Lol<v8::Cڋxt>::
New
(
x
);

52 
	gx
.
Dio
();

53  
	glx
;

58 
	gFay
<
	gv8
::
De
>::
tu_t


59 
Fay
<
v8
::
De
>::
New
(
vue
) {

60  
v8
::
De
::
New
(
vue
).
As
<v8::Date>();

65 
	gFay
<
	gv8
::
Ex
>::
tu_t


66 
Fay
<
v8
::
Ex
>::
New
(* 
vue
) {

67  
v8
::
Ex
::
New
(
vue
);

72 
	gFay
<
	gv8
::
Funi
>::
tu_t


73 
Fay
<
v8
::
Funi
>::
New

FuniClback
 
back


74 , 
v8
::
Lol
<v8::
Vue
> 
da
) {

75 
v8
::
HdSce
 
sce
;

77  
	gsce
.
Clo
(
Fay
<
v8
::
FuniTeme
>::
New
(

78 
back
, 
da
, 
v8
::
Lol
<v8::
Sigtu
>())

79 ->
GFuni
());

85 
	gFay
<
	gv8
::
FuniTeme
>::
tu_t


86 
Fay
<
v8
::
FuniTeme
>::
New

FuniClback
 
back


87 , 
v8
::
Lol
<v8::
Vue
> 
da


88 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
) {

89 i(
back
) {

90 
v8
::
HdSce
 
sce
;

92 
	gv8
::
Lol
<
v8
::
ObjeTeme
> 
l
 = v8::ObjeTeme::
New
();

93 
	gl
->
SIlFldCou
(
imp
::
kFuniFldCou
);

94 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
 = 
l
->
NewIn
();

96 
	gobj
->
SIlFld
(

97 
imp
::
kFuniIndex


98 , 
v8
::
Ex
::
New
(
t_
<*>(
back
)));

100 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = v8::Lol<v8::Vue>::
New
(
da
);

102 i(!
	gv
.
IsEmy
()) {

103 
	gobj
->
SIlFld
(
imp
::
kDaIndex
, 
v
);

108  
	gsce
.
Clo
(

109 
v8
::
FuniTeme
::
New
(
imp
::
FuniClbackW


110 , 
obj


111 , 
sigtu
));

113  
	gv8
::
FuniTeme
::
New
(0, 
da
, 
sigtu
);

119 
	gFay
<
	gv8
::
Numb
>::
tu_t


120 
Fay
<
v8
::
Numb
>::
New
(
vue
) {

121  
v8
::
Numb
::
New
(
vue
);

126 
	gFay
<
	gv8
::
NumbObje
>::
tu_t


127 
Fay
<
v8
::
NumbObje
>::
New
(
vue
) {

128  
v8
::
NumbObje
::
New
(
vue
).
As
<v8::NumberObject>();

133 
	gme
 <
tyme
 
	gT
>

134 
tyme
 
	gIegFay
<
	gT
>::
tu_t


135 
IegFay
<
T
>::
New
(
t32_t
 
vue
) {

136  
To
<
T
>(T::
New
(
vue
));

139 
	gme
 <
tyme
 
	gT
>

140 
tyme
 
	gIegFay
<
	gT
>::
tu_t


141 
IegFay
<
T
>::
New
(
ut32_t
 
vue
) {

142  
To
<
T
>(T::
NewFromUnsigd
(
vue
));

145 
	gFay
<
	gv8
::
Ut32
>::
tu_t


146 
Fay
<
v8
::
Ut32
>::
New
(
t32_t
 
vue
) {

147  
To
<
v8
::
Ut32
>(v8::Ut32::
NewFromUnsigd
(
vue
));

150 
	gFay
<
	gv8
::
Ut32
>::
tu_t


151 
Fay
<
v8
::
Ut32
>::
New
(
ut32_t
 
vue
) {

152  
To
<
v8
::
Ut32
>(v8::Ut32::
NewFromUnsigd
(
vue
));

158 
	gFay
<
	gv8
::
Obje
>::
tu_t


159 
Fay
<
v8
::
Obje
>::
New
() {

160  
v8
::
Obje
::
New
();

165 
	gFay
<
	gv8
::
ObjeTeme
>::
tu_t


166 
Fay
<
v8
::
ObjeTeme
>::
New
() {

167  
v8
::
ObjeTeme
::
New
();

172 
	gFay
<
	gv8
::
RegExp
>::
tu_t


173 
Fay
<
v8
::
RegExp
>::
New
(

174 
v8
::
Lol
<v8::
Sg
> 
n


175 , 
v8
::
RegExp
::
Fgs
 
ags
) {

176  
v8
::
RegExp
::
New
(
n
, 
ags
);

181 
	gFay
<
	gv8
::
St
>::
tu_t


182 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour
) {

183  
v8
::
St
::
New
(
sour
);

185 
	gFay
<
	gv8
::
St
>::
tu_t


186 
Fay
<
v8
::
St
>::
New
v8::
Lol
<v8::
Sg
> 
sour


187 , 
v8
::
StOrig
 cڡ& 
ig
) {

188  
v8
::
St
::
New
(
sour
, 
cڡ_
<v8::
StOrig
*>(&
ig
));

193 
	gFay
<
	gv8
::
Sigtu
>::
tu_t


194 
Fay
<
v8
::
Sigtu
>::
New
(Fay<v8::Sigtu>::
FTH
 
iv
) {

195  
v8
::
Sigtu
::
New
(
iv
);

200 
	gFay
<
	gv8
::
Sg
>::
tu_t


201 
Fay
<
v8
::
Sg
>::
New
() {

202  
v8
::
Sg
::
Emy
();

205 
	gFay
<
	gv8
::
Sg
>::
tu_t


206 
Fay
<
v8
::
Sg
>::
New
(cڡ * 
vue
, 
ngth
) {

207  
	gv8
::
Sg
::
New
(
vue
, 
ngth
);

210 
	gFay
<
	gv8
::
Sg
>::
tu_t


211 
Fay
<
v8
::
Sg
>::
New
(

212 
d
::
rg
 cڡ& 
vue
) {

213 
as
(
vue
.
size
(<
INT_MAX
 && "stringooong");

214  
	gv8
::
Sg
::
New
(
vue
.
da
(), 
ic_
<>(vue.
size
()));

217 
	gFay
<
	gv8
::
Sg
>::
tu_t


218 
Fay
<
v8
::
Sg
>::
New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

219  
	gv8
::
Sg
::
New
(
vue
, 
ngth
);

222 
	gFay
<
	gv8
::
Sg
>::
tu_t


223 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExSgResour
 * 
vue
) {

224  
v8
::
Sg
::
NewEx
(
vue
);

227 
	gFay
<
	gv8
::
Sg
>::
tu_t


228 
Fay
<
v8
::
Sg
>::
New
(v8::Sg::
ExAsciiSgResour
 * 
vue
) {

229  
v8
::
Sg
::
NewEx
(
vue
);

234 
	gFay
<
	gv8
::
SgObje
>::
tu_t


235 
Fay
<
v8
::
SgObje
>::
New
(v8::
Lol
<v8::
Sg
> 
vue
) {

236  
v8
::
SgObje
::
New
(
vue
).
As
<v8::StringObject>();

243 
	gme
 <
tyme
 
	gT
>

244 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
) {

245  
v8
::
Lol
<
T
>::
New
(
h
);

248 
	gme
 <
tyme
 
	gT
>

249 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T> cڡ& 
p
) {

250  
v8
::
Lol
<
T
>::
New
(
p
);

253 
	gme
 <
tyme
 
	gT
,ym
	gM
>

254 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
) {

255  
	gv8
::
Lol
<
T
>::
New
(
p
.
rsit
);

258 
	gme
 <
tyme
 
	gT
>

259 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
) {

260  
v8
::
Lol
<
T
>::
New
(
p
.
rsit
);

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_json.h

9 #ide
NAN_JSON_H_


10 
	#NAN_JSON_H_


	)

12 #i
NODE_MODULE_VERSION
 < 
NODE_0_12_MODULE_VERSION


13 
	#NAN_JSON_H_NEED_PARSE
 1

	)

15 
	#NAN_JSON_H_NEED_PARSE
 0

	)

18 #i
NODE_MODULE_VERSION
 >
NODE_7_0_MODULE_VERSION


19 
	#NAN_JSON_H_NEED_STRINGIFY
 0

	)

21 
	#NAN_JSON_H_NEED_STRINGIFY
 1

	)

24 as
	cJSON
 {

25 
	mpublic
:

26 
	$JSON
() {

27 #i
NAN_JSON_H_NEED_PARSE
 + 
NAN_JSON_H_NEED_STRINGIFY


28 
N
::
HdSce
 
sce
;

30 
N
::
MaybeLol
<
v8
::
Vue
> 
maybe_glob_js
 = N::
	`G
(

31 
N
::
	`GCutCڋxt
()->
	`Glob
(),

32 
N
::
	`New
("JSON").
	`ToLolChecked
()

35 
	`as
(!
maybe_glob_js
.
	`IsEmy
() && "global JSON ismpty");

36 
v8
::
Lol
<v8::
Vue
> 
v_glob_js
 = 
maybe_glob_js
.
	`ToLolChecked
();

38 
	`as
(
v_glob_js
->
	`IsObje
() && "global JSON isotn object");

39 
N
::
MaybeLol
<
v8
::
Obje
> 
maybe_obj_glob_js
 =

40 
N
::
To
<
v8
::
Obje
>(
v_glob_js
);

42 
	`as
(!
maybe_obj_glob_js
.
	`IsEmy
() && "global JSON object ismpty");

43 
v8
::
Lol
<v8::
Obje
> 
glob_js
 = 
maybe_obj_glob_js
.
	`ToLolChecked
();

45 #i
NAN_JSON_H_NEED_PARSE


46 
N
::
MaybeLol
<
v8
::
Vue
> 
maybe_r_mhod
 = N::
	`G
(

47 
glob_js
, 
N
::
	`New
("r").
	`ToLolChecked
()

50 
	`as
(!
maybe_r_mhod
.
	`IsEmy
() && "JSON.parse ismpty");

51 
v8
::
Lol
<v8::
Vue
> 
r_mhod
 = 
maybe_r_mhod
.
	`ToLolChecked
();

53 
	`as
(
r_mhod
->
	`IsFuni
() && "JSON.parse isot function");

54 
r_cb_
.
	`Ret
(
r_mhod
.
As
<
v8
::
Funi
>());

57 #i
NAN_JSON_H_NEED_STRINGIFY


58 
N
::
MaybeLol
<
v8
::
Vue
> 
maybe_rgify_mhod
 = N::
	`G
(

59 
glob_js
, 
N
::
	`New
("rgify").
	`ToLolChecked
()

62 
	`as
(!
maybe_rgify_mhod
.
	`IsEmy
() && "JSON.stringify ismpty");

63 
v8
::
Lol
<v8::
Vue
> 
rgify_mhod
 =

64 
maybe_rgify_mhod
.
	`ToLolChecked
();

66 
	`as
(

67 
rgify_mhod
->
	`IsFuni
() && "JSON.stringify isot function"

69 
rgify_cb_
.
	`Ret
(
rgify_mhod
.
As
<
v8
::
Funi
>());

74 
le


75 
N
::
MaybeLol
<
v8
::
Vue
> 
	`P
(v8::
Lol
<v8::
Sg
> 
js_rg
) {

76 
N
::
EsbHdSce
 
sce
;

77 #i
NAN_JSON_H_NEED_PARSE


78  
sce
.
	`Es
(
	`r
(
js_rg
));

80 
N
::
MaybeLol
<
v8
::
Vue
> 
su
;

81 #i
NODE_MODULE_VERSION
 >
NODE_0_12_MODULE_VERSION
 && \

82 
NODE_MODULE_VERSION
 <
IOJS_2_0_MODULE_VERSION


83 
su
 = 
v8
::
JSON
::
	`P
(
js_rg
);

85 #i
NODE_MODULE_VERSION
 > 
NODE_6_0_MODULE_VERSION


86 
v8
::
Lol
<v8::
Cڋxt
> 
cڋxt__isީe
 = 
N
::
	`GCutCڋxt
();

88 
v8
::
Isީe
* 
cڋxt__isީe
 = v8::Isީe::
	`GCut
();

90 
su
 = 
v8
::
JSON
::
	`P
(
cڋxt__isީe
, 
js_rg
);

93 i(
su
.
	`IsEmy
() 
v8
::
Lol
<v8::
Vue
>();

94  
sce
.
	`Es
(
su
.
	`ToLolChecked
());

96 
	}
}

98 
le


99 
	gN
::
MaybeLol
<
v8
::
Sg
> 
Sgify
(v8::
Lol
<v8::
Obje
> 
js_obje
) {

100 
N
::
EsbHdSce
 
sce
;

101 
	gN
::
MaybeLol
<
v8
::
Sg
> 
su
 =

102 #i
NAN_JSON_H_NEED_STRINGIFY


103 
N
::
To
<
v8
::
Sg
>(
rgify
(
js_obje
));

105 
	gv8
::
JSON
::
Sgify
(
N
::
GCutCڋxt
(), 
js_obje
);

107 i(
	gsu
.
IsEmy
() 
	gv8
::
Lol
<
v8
::
Sg
>();

108  
	gsce
.
Es
(
su
.
ToLolChecked
());

111 
le


112 
	gN
::
MaybeLol
<
v8
::
Sg
> 
Sgify
(v8::
Lol
<v8::
Obje
> 
js_obje
,

113 
v8
::
Lol
<v8::
Sg
> 
g
) {

114 
N
::
EsbHdSce
 
sce
;

115 
	gN
::
MaybeLol
<
v8
::
Sg
> 
su
 =

116 #i
NAN_JSON_H_NEED_STRINGIFY


117 
N
::
To
<
v8
::
Sg
>(
rgify
(
js_obje
, 
g
));

119 
	gv8
::
JSON
::
Sgify
(
N
::
GCutCڋxt
(), 
js_obje
, 
g
);

121 i(
	gsu
.
IsEmy
() 
	gv8
::
Lol
<
v8
::
Sg
>();

122  
	gsce
.
Es
(
su
.
ToLolChecked
());

125 
	give
:

126 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
JSON
)

127 #i
NAN_JSON_H_NEED_PARSE


128 
N
::
Clback
 
r_cb_
;

130 #i
NAN_JSON_H_NEED_STRINGIFY


131 
N
::
Clback
 
rgify_cb_
;

134 #i
NAN_JSON_H_NEED_PARSE


135 
le
 
v8
::
Lol
<v8::
Vue
> 
	`r
(v8::Lol<v8::Vue> 
g
) {

136 
	`as
(!
r_cb_
.
	`IsEmy
() && "parse_cb_ ismpty");

137 
AsyncResour
 
	`sour
("nan:JSON.parse");

138  
r_cb_
.
	`Cl
(1, &
g
, &
sour
).
	`FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

139 
	}
}

142 #i
NAN_JSON_H_NEED_STRINGIFY


143 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
rgify
(v8::Lol<v8::Vue> 
g
) {

144 
as
(!
rgify_cb_
.
IsEmy
() && "stringify_cb_ ismpty");

145 
AsyncResour
 
sour
("nan:JSON.stringify");

146  
	grgify_cb_
.
Cl
(1, &
g
, &
sour
)

147 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

150 
le
 
	gv8
::
Lol
<
v8
::
Vue
> 
rgify
(v8::Lol<v8::Vue> 
g
,

151 
v8
::
Lol
<v8::
Sg
> 
g
) {

152 
as
(!
rgify_cb_
.
IsEmy
() && "stringify_cb_ ismpty");

154 
	gv8
::
Lol
<
v8
::
Vue
> 
gv
[] = {

155 
g
,

156 
N
::
Nu
(),

157 
g


159 
AsyncResour
 
sour
("nan:JSON.stringify");

160  
	grgify_cb_
.
Cl
(3, 
gv
, &
sour
)

161 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>());

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_maybe_43_inl.h

9 #ide
NAN_MAYBE_43_INL_H_


10 
	#NAN_MAYBE_43_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 
usg
 
	gMaybeLol
 = 
v8
::
MaybeLol
<
T
>;

15 
le


16 
	gMaybeLol
<
	gv8
::
Sg
> 
ToDaSg
(
v8
::
Lol
<v8::
Vue
> 
v
) {

17 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

18 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

19  
	gsce
.
Es
(
v
->
ToDaSg
(
isީe
->
GCutCڋxt
())

20 .
FromMaybe
(
v8
::
Lol
<v8::
Sg
>()));

23 
le


24 
	gMaybeLol
<
	gv8
::
Ut32
> 
ToAayIndex
(
v8
::
Lol
<v8::
Vue
> 
v
) {

25 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

26 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

27  
	gsce
.
Es
(
v
->
ToAayIndex
(
isީe
->
GCutCڋxt
())

28 .
FromMaybe
(
v8
::
Lol
<v8::
Ut32
>()));

31 
le


32 
	gMaybe
<
	gbo
> 
Equs
(
v8
::
Lol
<v8::
Vue
> 
a
, v8::Lol<v8::Vue>(
b
)) {

33 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

34 
	gv8
::
HdSce
 
sce
(
isީe
);

35  
	ga
->
Equs
(
isީe
->
GCutCڋxt
(), 
b
);

38 
le


39 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Lol
<v8::
Funi
> 
h
) {

40 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

41 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

42  
	gsce
.
Es
(
h
->
NewIn
(
isީe
->
GCutCڋxt
())

43 .
FromMaybe
(
v8
::
Lol
<v8::
Obje
>()));

46 
le


47 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(

48 
v8
::
Lol
<v8::
Funi
> 
h


49 , 
gc


50 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

51 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

52 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

53  
	gsce
.
Es
(
h
->
NewIn
(
isީe
->
GCutCڋxt
(), 
gc
, 
gv
)

54 .
FromMaybe
(
v8
::
Lol
<v8::
Obje
>()));

57 
le


58 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Lol
<v8::
ObjeTeme
> 
h
) {

59 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

60 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

61  
	gsce
.
Es
(
h
->
NewIn
(
isީe
->
GCutCڋxt
())

62 .
FromMaybe
(
v8
::
Lol
<v8::
Obje
>()));

66 
le
 
	gMaybeLol
<
	gv8
::
Funi
> 
GFuni
(

67 
v8
::
Lol
<v8::
FuniTeme
> 
t
) {

68 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

69 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

70  
	gsce
.
Es
(
t
->
GFuni
(
isީe
->
GCutCڋxt
())

71 .
FromMaybe
(
v8
::
Lol
<v8::
Funi
>()));

74 
le
 
	gMaybe
<
	gbo
> 
S
(

75 
v8
::
Lol
<v8::
Obje
> 
obj


76 , 
v8
::
Lol
<v8::
Vue
> 
key


77 , 
v8
::
Lol
<v8::
Vue
> 
vue
) {

78 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

79 
	gv8
::
HdSce
 
sce
(
isީe
);

80  
	gobj
->
S
(
isީe
->
GCutCڋxt
(), 
key
, 
vue
);

83 
le
 
	gMaybe
<
	gbo
> 
S
(

84 
v8
::
Lol
<v8::
Obje
> 
obj


85 , 
ut32_t
 
dex


86 , 
v8
::
Lol
<v8::
Vue
> 
vue
) {

87 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

88 
	gv8
::
HdSce
 
sce
(
isީe
);

89  
	gobj
->
S
(
isީe
->
GCutCڋxt
(), 
dex
, 
vue
);

92 #i
NODE_MODULE_VERSION
 < 
NODE_4_0_MODULE_VERSION


93 
	~"n_defe_own_ݔty_hr.h
"

96 
le
 
	gMaybe
<
	gbo
> 
DefeOwnPrݔty
(

97 
v8
::
Lol
<v8::
Obje
> 
obj


98 , 
v8
::
Lol
<v8::
Sg
> 
key


99 , 
v8
::
Lol
<v8::
Vue
> 
vue


100 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

101 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

102 
	gv8
::
HdSce
 
sce
(
isީe
);

103 #i
NODE_MODULE_VERSION
 >
NODE_4_0_MODULE_VERSION


104  
	gobj
->
DefeOwnPrݔty
(
isީe
->
GCutCڋxt
(), 
key
, 
vue
,

105 
ibs
);

107 
	gMaybe
<
	gv8
::
PrݔtyAribu
> 
maybeCut
 =

108 
obj
->
GPrݔtyAribus
(
isީe
->
GCutCڋxt
(), 
key
);

109 i(
	gmaybeCut
.
IsNhg
()) {

110  
	gNhg
<
	gbo
>();

112 
	gv8
::
PrݔtyAribu
 
cut
 = 
maybeCut
.
FromJu
();

113  
	gimp
::
DefeOwnPrݔtyHr
(
cut
, 
obj
, 
key
, 
vue
, 
ibs
);

117 
NAN_DEPRECATED
 
le
 
	gMaybe
<
	gbo
> 
FS
(

118 
v8
::
Lol
<v8::
Obje
> 
obj


119 , 
v8
::
Lol
<v8::
Vue
> 
key


120 , 
v8
::
Lol
<v8::
Vue
> 
vue


121 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

122 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

123 
	gv8
::
HdSce
 
sce
(
isީe
);

124 #i
NODE_MODULE_VERSION
 >
NODE_9_0_MODULE_VERSION


125  
	gkey
->
IsName
()

126 ? 
	gobj
->
DefeOwnPrݔty
(
isީe
->
GCutCڋxt
(),

127 
key
.
As
<
v8
::
Name
>(), 
vue
, 
ibs
)

128 : 
Nhg
<
bo
>();

130  
	gobj
->
FS
(
isީe
->
GCutCڋxt
(), 
key
, 
vue
, 
ibs
);

134 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

135 
v8
::
Lol
<v8::
Obje
> 
obj


136 , 
v8
::
Lol
<v8::
Vue
> 
key
) {

137 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

138 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

139  
	gsce
.
Es
(
obj
->
G
(
isީe
->
GCutCڋxt
(), 
key
)

140 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

143 
le


144 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

145 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

146 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

147  
	gsce
.
Es
(
obj
->
G
(
isީe
->
GCutCڋxt
(), 
dex
)

148 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

151 
le
 
	gv8
::
PrݔtyAribu
 
GPrݔtyAribus
(

152 
v8
::
Lol
<v8::
Obje
> 
obj


153 , 
v8
::
Lol
<v8::
Vue
> 
key
) {

154 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

155 
	gv8
::
HdSce
 
sce
(
isީe
);

156  
	gobj
->
GPrݔtyAribus
(
isީe
->
GCutCڋxt
(), 
key
)

157 .
FromJu
();

160 
le
 
	gMaybe
<
	gbo
> 
Has
(

161 
v8
::
Lol
<v8::
Obje
> 
obj


162 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

163 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

164 
	gv8
::
HdSce
 
sce
(
isީe
);

165  
	gobj
->
Has
(
isީe
->
GCutCڋxt
(), 
key
);

168 
le
 
	gMaybe
<
	gbo
> 
Has
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

169 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

170 
	gv8
::
HdSce
 
sce
(
isީe
);

171  
	gobj
->
Has
(
isީe
->
GCutCڋxt
(), 
dex
);

174 
le
 
	gMaybe
<
	gbo
> 
De
(

175 
v8
::
Lol
<v8::
Obje
> 
obj


176 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

177 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

178 
	gv8
::
HdSce
 
sce
(
isީe
);

179  
	gobj
->
De
(
isީe
->
GCutCڋxt
(), 
key
);

182 
le


183 
	gMaybe
<
	gbo
> 
De
(
v8
::
Lol
<v8::
Obje
> 
obj
, 
ut32_t
 
dex
) {

184 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

185 
	gv8
::
HdSce
 
sce
(
isީe
);

186  
	gobj
->
De
(
isީe
->
GCutCڋxt
(), 
dex
);

189 
le


190 
	gMaybeLol
<
	gv8
::
Aay
> 
GPrݔtyNames
(
v8
::
Lol
<v8::
Obje
> 
obj
) {

191 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

192 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

193  
	gsce
.
Es
(
obj
->
GPrݔtyNames
(
isީe
->
GCutCڋxt
())

194 .
FromMaybe
(
v8
::
Lol
<v8::
Aay
>()));

197 
le


198 
	gMaybeLol
<
	gv8
::
Aay
> 
GOwnPrݔtyNames
(
v8
::
Lol
<v8::
Obje
> 
obj
) {

199 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

200 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

201  
	gsce
.
Es
(
obj
->
GOwnPrݔtyNames
(
isީe
->
GCutCڋxt
())

202 .
FromMaybe
(
v8
::
Lol
<v8::
Aay
>()));

205 
le
 
	gMaybe
<
	gbo
> 
SPry
(

206 
v8
::
Lol
<v8::
Obje
> 
obj


207 , 
v8
::
Lol
<v8::
Vue
> 
y
) {

208 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

209 
	gv8
::
HdSce
 
sce
(
isީe
);

210  
	gobj
->
SPry
(
isީe
->
GCutCڋxt
(), 
y
);

213 
le
 
	gMaybeLol
<
	gv8
::
Sg
> 
ObjeProToSg
(

214 
v8
::
Lol
<v8::
Obje
> 
obj
) {

215 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

216 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

217  
	gsce
.
Es
(
obj
->
ObjeProToSg
(
isީe
->
GCutCڋxt
())

218 .
FromMaybe
(
v8
::
Lol
<v8::
Sg
>()));

221 
le
 
	gMaybe
<
	gbo
> 
HasOwnPrݔty
(

222 
v8
::
Lol
<v8::
Obje
> 
obj


223 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

224 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

225 
	gv8
::
HdSce
 
sce
(
isީe
);

226  
	gobj
->
HasOwnPrݔty
(
isީe
->
GCutCڋxt
(), 
key
);

229 
le
 
	gMaybe
<
	gbo
> 
HasRlNamedPrݔty
(

230 
v8
::
Lol
<v8::
Obje
> 
obj


231 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

232 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

233 
	gv8
::
HdSce
 
sce
(
isީe
);

234  
	gobj
->
HasRlNamedPrݔty
(
isީe
->
GCutCڋxt
(), 
key
);

237 
le
 
	gMaybe
<
	gbo
> 
HasRlIndexedPrݔty
(

238 
v8
::
Lol
<v8::
Obje
> 
obj


239 , 
ut32_t
 
dex
) {

240 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

241 
	gv8
::
HdSce
 
sce
(
isީe
);

242  
	gobj
->
HasRlIndexedPrݔty
(
isީe
->
GCutCڋxt
(), 
dex
);

245 
le
 
	gMaybe
<
	gbo
> 
HasRlNamedClbackPrݔty
(

246 
v8
::
Lol
<v8::
Obje
> 
obj


247 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

248 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

249 
	gv8
::
HdSce
 
sce
(
isީe
);

250  
	gobj
->
HasRlNamedClbackPrݔty
(
isީe
->
GCutCڋxt
(), 
key
);

253 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔtyInPryCha
(

254 
v8
::
Lol
<v8::
Obje
> 
obj


255 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

256 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

257 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

258  
	gsce
.
Es
(
obj
->
GRlNamedPrݔtyInPryCha
(

259 
isީe
->
GCutCڋxt
(), 
key
)

260 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

263 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔty
(

264 
v8
::
Lol
<v8::
Obje
> 
obj


265 , 
v8
::
Lol
<v8::
Sg
> 
key
) {

266 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

267 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

268  
	gsce
.
Es
(

269 
obj
->
GRlNamedPrݔty
(
isީe
->
GCutCڋxt
(), 
key
)

270 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

273 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsFuni
(

274 
v8
::
Lol
<v8::
Obje
> 
obj


275 , 
v8
::
Lol
<v8::
Obje
> 
cv


276 , 
gc


277 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

278 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

279 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

280  
	gsce
.
Es
(

281 
obj
->
ClAsFuni
(
isީe
->
GCutCڋxt
(), 
cv
, 
gc
, 
gv
)

282 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

285 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsCڡru
(

286 
v8
::
Lol
<v8::
Obje
> 
obj


287 , 
gc
, 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

288 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

289 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

290  
	gsce
.
Es
(

291 
obj
->
ClAsCڡru
(
isީe
->
GCutCڋxt
(), 
gc
, 
gv
)

292 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

295 
le


296 
	gMaybeLol
<
	gv8
::
Sg
> 
GSourLe
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

297 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

298 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

299  
	gsce
.
Es
(
msg
->
GSourLe
(
isީe
->
GCutCڋxt
())

300 .
FromMaybe
(
v8
::
Lol
<v8::
Sg
>()));

303 
le
 
	gMaybe
<> 
GLeNumb
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

304 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

305 
	gv8
::
HdSce
 
sce
(
isީe
);

306  
	gmsg
->
GLeNumb
(
isީe
->
GCutCڋxt
());

309 
le
 
	gMaybe
<> 
GSCumn
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

310 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

311 
	gv8
::
HdSce
 
sce
(
isީe
);

312  
	gmsg
->
GSCumn
(
isީe
->
GCutCڋxt
());

315 
le
 
	gMaybe
<> 
GEndCumn
(
v8
::
Lol
<v8::
Mesge
> 
msg
) {

316 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

317 
	gv8
::
HdSce
 
sce
(
isީe
);

318  
	gmsg
->
GEndCumn
(
isީe
->
GCutCڋxt
());

321 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
CleEmtAt
(

322 
v8
::
Lol
<v8::
Aay
> 
y


323 , 
ut32_t
 
dex
) {

324 #i(
NODE_MODULE_VERSION
 >
NODE_6_0_MODULE_VERSION
)

325 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

326 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

327 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
cڋxt
 = 
isީe
->
GCutCڋxt
();

328 
	gv8
::
Lol
<
v8
::
Vue
> 
em
;

329 
	gv8
::
Lol
<
v8
::
Obje
> 
obj
;

330 i(!
	gy
->
G
(
cڋxt
, 
dex
).
ToLol
(&
em
)) {

331  
	gsce
.
Es
(
obj
);

333 i(!
	gem
->
ToObje
(
cڋxt
).
ToLol
(&
obj
)) {

334  
	gsce
.
Es
(
v8
::
Lol
<v8::
Obje
>());

336  
	gsce
.
Es
(
obj
->
Cle
());

338 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

339 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

340  
	gsce
.
Es
(
y
->
CleEmtAt
(
isީe
->
GCutCڋxt
(), 
dex
)

341 .
FromMaybe
(
v8
::
Lol
<v8::
Obje
>()));

345 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

346 
v8
::
Lol
<v8::
Funi
> 
fun


347 , 
v8
::
Lol
<v8::
Obje
> 
cv


348 , 
gc


349 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

350 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

351 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

352  
	gsce
.
Es
(
fun
->
Cl
(
isީe
->
GCutCڋxt
(), 
cv
, 
gc
, 
gv
)

353 .
FromMaybe
(
v8
::
Lol
<v8::
Vue
>()));

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_maybe_pre_43_inl.h

9 #ide
NAN_MAYBE_PRE_43_INL_H_


10 
	#NAN_MAYBE_PRE_43_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cMaybeLol
 {

14 
	mpublic
:

15 
le
 
	$MaybeLol
(: 
	`v_
(
v8
::
Lol
<
T
>()) {}

17 
me
<
tyme
 
S
>

18 #i
NODE_MODULE_VERSION
 >
NODE_0_12_MODULE_VERSION


19 
le


20 
	`MaybeLol
(
v8
::
Lol
<
S
> 
th
: 
	$v_
(
th
{
	}
}

22 
le


23 
MaybeLol
(
v8
::
Lol
<
S
> 
th
) :

24 
v_
(*
t_
<
v8
::
Lol
<
T
>*>(&
th
)) {}

27 
le
 
bo
 
	$IsEmy
(cڡ {  
v_
.
	`IsEmy
(); 
	}
}

29 
	gme
<
tyme
 
	gS
>

30 
le
 
bo
 
ToLol
(
v8
::
Lol
<
S
> *
out
) const {

31 *
out
 = 
v_
;

32  !
IsEmy
();

35 
le
 
	gv8
::
Lol
<
T
> 
	$ToLolChecked
() const {

36 #i
	`defed
(
V8_ENABLE_CHECKS
)

37 
	`as
(!
	`IsEmy
() && "ToLocalChecked is Empty");

39  
v_
;

40 
	}
}

42 
	gme
<
tyme
 
	gS
>

43 
le
 
	gv8
::
Lol
<
S
> 
FromMaybe
(
v8
::Lol<S> 
deu_vue
) const {

44  
IsEmy
(? 
deu_vue
 : 
v8
::
Lol
<
S
>(
v_
);

47 
	give
:

48 
v8
::
Lol
<
T
> 
v_
;

51 
le


52 
	gMaybeLol
<
	gv8
::
Sg
> 
ToDaSg
(
v8
::
Hd
<v8::
Vue
> 
v
) {

53  
MaybeLol
<
v8
::
Sg
>(
v
->
ToDaSg
());

56 
le


57 
	gMaybeLol
<
	gv8
::
Ut32
> 
ToAayIndex
(
v8
::
Hd
<v8::
Vue
> 
v
) {

58  
MaybeLol
<
v8
::
Ut32
>(
v
->
ToAayIndex
());

61 
le


62 
	gMaybe
<
	gbo
> 
Equs
(
v8
::
Hd
<v8::
Vue
> 
a
, v8::Hd<v8::Vue>(
b
)) {

63  
Ju
<
bo
>(
a
->
Equs
(
b
));

66 
le


67 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Hd
<v8::
Funi
> 
h
) {

68  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
());

71 
le


72 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(

73 
v8
::
Lol
<v8::
Funi
> 
h


74 , 
gc


75 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

76  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
(
gc
, 
gv
));

79 
le


80 
	gMaybeLol
<
	gv8
::
Obje
> 
NewIn
(
v8
::
Hd
<v8::
ObjeTeme
> 
h
) {

81  
MaybeLol
<
v8
::
Obje
>(
h
->
NewIn
());

84 
le


85 
	gMaybeLol
<
	gv8
::
Funi
> 
GFuni
(
v8
::
Hd
<v8::
FuniTeme
> 
t
) {

86  
MaybeLol
<
v8
::
Funi
>(
t
->
GFuni
());

89 
le
 
	gMaybe
<
	gbo
> 
S
(

90 
v8
::
Hd
<v8::
Obje
> 
obj


91 , 
v8
::
Hd
<v8::
Vue
> 
key


92 , 
v8
::
Hd
<v8::
Vue
> 
vue
) {

93  
Ju
<
bo
>(
obj
->
S
(
key
, 
vue
));

96 
le
 
	gMaybe
<
	gbo
> 
S
(

97 
v8
::
Hd
<v8::
Obje
> 
obj


98 , 
ut32_t
 
dex


99 , 
v8
::
Hd
<v8::
Vue
> 
vue
) {

100  
Ju
<
bo
>(
obj
->
S
(
dex
, 
vue
));

103 
	~"n_defe_own_ݔty_hr.h
"

105 
le
 
	gMaybe
<
	gbo
> 
DefeOwnPrݔty
(

106 
v8
::
Hd
<v8::
Obje
> 
obj


107 , 
v8
::
Hd
<v8::
Sg
> 
key


108 , 
v8
::
Hd
<v8::
Vue
> 
vue


109 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

110 
v8
::
PrݔtyAribu
 
cut
 = 
obj
->
GPrݔtyAribus
(
key
);

111  
	gimp
::
DefeOwnPrݔtyHr
(
cut
, 
obj
, 
key
, 
vue
, 
ibs
);

114 
NAN_DEPRECATED
 
le
 
	gMaybe
<
	gbo
> 
FS
(

115 
v8
::
Hd
<v8::
Obje
> 
obj


116 , 
v8
::
Hd
<v8::
Vue
> 
key


117 , 
v8
::
Hd
<v8::
Vue
> 
vue


118 , 
v8
::
PrݔtyAribu
 
ibs
 = v8::
Ne
) {

119  
Ju
<
bo
>(
obj
->
FS
(
key
, 
vue
, 
ibs
));

122 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

123 
v8
::
Hd
<v8::
Obje
> 
obj


124 , 
v8
::
Hd
<v8::
Vue
> 
key
) {

125  
MaybeLol
<
v8
::
Vue
>(
obj
->
G
(
key
));

128 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
G
(

129 
v8
::
Hd
<v8::
Obje
> 
obj


130 , 
ut32_t
 
dex
) {

131  
	gMaybeLol
<
	gv8
::
Vue
>(
obj
->
G
(
dex
));

134 
le
 
	gMaybe
<
	gv8
::
PrݔtyAribu
> 
GPrݔtyAribus
(

135 
v8
::
Hd
<v8::
Obje
> 
obj


136 , 
v8
::
Hd
<v8::
Vue
> 
key
) {

137  
Ju
<
v8
::
PrݔtyAribu
>(
obj
->
GPrݔtyAribus
(
key
));

140 
le
 
	gMaybe
<
	gbo
> 
Has
(

141 
v8
::
Hd
<v8::
Obje
> 
obj


142 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

143  
Ju
<
bo
>(
obj
->
Has
(
key
));

146 
le
 
	gMaybe
<
	gbo
> 
Has
(

147 
v8
::
Hd
<v8::
Obje
> 
obj


148 , 
ut32_t
 
dex
) {

149  
	gJu
<
	gbo
>(
	gobj
->
Has
(
dex
));

152 
le
 
	gMaybe
<
	gbo
> 
De
(

153 
v8
::
Hd
<v8::
Obje
> 
obj


154 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

155  
Ju
<
bo
>(
obj
->
De
(
key
));

158 
le
 
	gMaybe
<
	gbo
> 
De
(

159 
v8
::
Hd
<v8::
Obje
> 
obj


160 , 
ut32_t
 
dex
) {

161  
	gJu
<
	gbo
>(
	gobj
->
De
(
dex
));

164 
le


165 
	gMaybeLol
<
	gv8
::
Aay
> 
GPrݔtyNames
(
v8
::
Hd
<v8::
Obje
> 
obj
) {

166  
MaybeLol
<
v8
::
Aay
>(
obj
->
GPrݔtyNames
());

169 
le


170 
	gMaybeLol
<
	gv8
::
Aay
> 
GOwnPrݔtyNames
(
v8
::
Hd
<v8::
Obje
> 
obj
) {

171  
MaybeLol
<
v8
::
Aay
>(
obj
->
GOwnPrݔtyNames
());

174 
le
 
	gMaybe
<
	gbo
> 
SPry
(

175 
v8
::
Hd
<v8::
Obje
> 
obj


176 , 
v8
::
Hd
<v8::
Vue
> 
y
) {

177  
Ju
<
bo
>(
obj
->
SPry
(
y
));

180 
le
 
	gMaybeLol
<
	gv8
::
Sg
> 
ObjeProToSg
(

181 
v8
::
Hd
<v8::
Obje
> 
obj
) {

182  
MaybeLol
<
v8
::
Sg
>(
obj
->
ObjeProToSg
());

185 
le
 
	gMaybe
<
	gbo
> 
HasOwnPrݔty
(

186 
v8
::
Hd
<v8::
Obje
> 
obj


187 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

188  
Ju
<
bo
>(
obj
->
HasOwnPrݔty
(
key
));

191 
le
 
	gMaybe
<
	gbo
> 
HasRlNamedPrݔty
(

192 
v8
::
Hd
<v8::
Obje
> 
obj


193 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

194  
Ju
<
bo
>(
obj
->
HasRlNamedPrݔty
(
key
));

197 
le
 
	gMaybe
<
	gbo
> 
HasRlIndexedPrݔty
(

198 
v8
::
Hd
<v8::
Obje
> 
obj


199 , 
ut32_t
 
dex
) {

200  
	gJu
<
	gbo
>(
	gobj
->
HasRlIndexedPrݔty
(
dex
));

203 
le
 
	gMaybe
<
	gbo
> 
HasRlNamedClbackPrݔty
(

204 
v8
::
Hd
<v8::
Obje
> 
obj


205 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

206  
Ju
<
bo
>(
obj
->
HasRlNamedClbackPrݔty
(
key
));

209 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔtyInPryCha
(

210 
v8
::
Hd
<v8::
Obje
> 
obj


211 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

212  
MaybeLol
<
v8
::
Vue
>(

213 
obj
->
GRlNamedPrݔtyInPryCha
(
key
));

216 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
GRlNamedPrݔty
(

217 
v8
::
Hd
<v8::
Obje
> 
obj


218 , 
v8
::
Hd
<v8::
Sg
> 
key
) {

219  
MaybeLol
<
v8
::
Vue
>(
obj
->
GRlNamedPrݔty
(
key
));

222 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsFuni
(

223 
v8
::
Hd
<v8::
Obje
> 
obj


224 , 
v8
::
Hd
<v8::
Obje
> 
cv


225 , 
gc


226 , 
v8
::
Hd
<v8::
Vue
> 
gv
[]) {

227  
MaybeLol
<
v8
::
Vue
>(
obj
->
ClAsFuni
(
cv
, 
gc
, 
gv
));

230 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
ClAsCڡru
(

231 
v8
::
Hd
<v8::
Obje
> 
obj


232 , 
gc


233 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

234  
MaybeLol
<
v8
::
Vue
>(
obj
->
ClAsCڡru
(
gc
, 
gv
));

237 
le


238 
	gMaybeLol
<
	gv8
::
Sg
> 
GSourLe
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

239  
MaybeLol
<
v8
::
Sg
>(
msg
->
GSourLe
());

242 
le
 
	gMaybe
<> 
GLeNumb
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

243  
Ju
<>(
msg
->
GLeNumb
());

246 
le
 
	gMaybe
<> 
GSCumn
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

247  
Ju
<>(
msg
->
GSCumn
());

250 
le
 
	gMaybe
<> 
GEndCumn
(
v8
::
Hd
<v8::
Mesge
> 
msg
) {

251  
Ju
<>(
msg
->
GEndCumn
());

254 
le
 
	gMaybeLol
<
	gv8
::
Obje
> 
CleEmtAt
(

255 
v8
::
Hd
<v8::
Aay
> 
y


256 , 
ut32_t
 
dex
) {

257  
	gMaybeLol
<
	gv8
::
Obje
>(
y
->
CleEmtAt
(
dex
));

260 
le
 
	gMaybeLol
<
	gv8
::
Vue
> 
Cl
(

261 
v8
::
Lol
<v8::
Funi
> 
fun


262 , 
v8
::
Lol
<v8::
Obje
> 
cv


263 , 
gc


264 , 
v8
::
Lol
<v8::
Vue
> 
gv
[]) {

265  
MaybeLol
<
v8
::
Vue
>(
fun
->
Cl
(
cv
, 
gc
, 
gv
));

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_new.h

9 #ide
NAN_NEW_H_


10 
	#NAN_NEW_H_


	)

12 
mea
 
	gimp
 {

15 
	gme
 <
tyme
 
	gT
> 
	gv8
::
Lol
<
T
> 
To
(
v8
::Lol<v8::
Ieg
> 
i
);

17 
	gme
 <>

18 
le


19 
	gv8
::
Lol
<
v8
::
Ieg
>

20 
To
<
v8
::
Ieg
>(v8::
Lol
<v8::Ieg> 
i
) {

21  
N
::
To
<
v8
::
Ieg
>(
i
).
ToLolChecked
();

24 
	gme
 <>

25 
le


26 
	gv8
::
Lol
<
v8
::
I32
>

27 
To
<
v8
::
I32
>(v8::
Lol
<v8::
Ieg
> 
i
) {

28  
N
::
To
<
v8
::
I32
>(
i
).
ToLolChecked
();

31 
	gme
 <>

32 
le


33 
	gv8
::
Lol
<
v8
::
Ut32
>

34 
To
<
v8
::
Ut32
>(v8::
Lol
<v8::
Ieg
> 
i
) {

35  
N
::
To
<
v8
::
Ut32
>(
i
).
ToLolChecked
();

38 
	gme
 <
tyme
 
	gT
> 
	sFayBa
 {

39 
	gv8
::
	tLol
<
	tT
> 
	ttu_t
;

42 
	gme
 <
tyme
 
	gT
> 
	sMaybeFayBa
 {

43 
	gMaybeLol
<
	tT
> 
	ttu_t
;

46 
	gme
 <
tyme
 
	gT
> 
	gFay
;

48 
	gme
 <>

49 
	gFay
<
	gv8
::
Aay
> : 
FayBa
<
v8
::Array> {

50 
le
 
tu_t
 
New
();

51 
le
 
tu_t
 
New
(
ngth
);

54 
	gme
 <>

55 
	gFay
<
	gv8
::
Boޗn
> : 
FayBa
<
v8
::Boolean> {

56 
le
 
tu_t
 
New
(
bo
 
vue
);

59 
	gme
 <>

60 
	gFay
<
	gv8
::
BoޗnObje
> : 
FayBa
<
v8
::BooleanObject> {

61 
le
 
tu_t
 
New
(
bo
 
vue
);

64 
	gme
 <>

65 
	gFay
<
	gv8
::
Cڋxt
> : 
FayBa
<
v8
::Context> {

66 
le


67 
tu_t


68 
New

v8
::
ExnsiCfiguti
* 
exnsis
 = 
NULL


69 , 
v8
::
Lol
<v8::
ObjeTeme
> 
tm
 = v8::Local<v8::ObjectTemplate>()

70 , 
v8
::
Lol
<v8::
Vue
> 
obj
 = v8::Local<v8::Value>());

73 
	gme
 <>

74 
	gFay
<
	gv8
::
De
> : 
MaybeFayBa
<
v8
::Date> {

75 
le
 
tu_t
 
New
(
vue
);

78 
	gme
 <>

79 
	gFay
<
	gv8
::
Ex
> : 
FayBa
<
v8
::External> {

80 
le
 
tu_t
 
New
(*
vue
);

83 
	gme
 <>

84 
	gFay
<
	gv8
::
Funi
> : 
FayBa
<
v8
::Function> {

85 
le


86 
tu_t


87 
New

FuniClback
 
back


88 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>());

91 
	gme
 <>

92 
	gFay
<
	gv8
::
FuniTeme
> : 
FayBa
<
v8
::FunctionTemplate> {

93 
le


94 
tu_t


95 
New

FuniClback
 
back
 = 
NULL


96 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

97 , 
v8
::
Lol
<v8::
Sigtu
> 
sigtu
 = v8::Local<v8::Signature>());

100 
	gme
 <>

101 
	gFay
<
	gv8
::
Numb
> : 
FayBa
<
v8
::Number> {

102 
le
 
tu_t
 
New
(
vue
);

105 
	gme
 <>

106 
	gFay
<
	gv8
::
NumbObje
> : 
FayBa
<
v8
::NumberObject> {

107 
le
 
tu_t
 
New
(
vue
);

110 
	gme
 <
tyme
 
	gT
>

111 
	gIegFay
 : 
FayBa
<
T
> {

112 
tyme
 
	tFayBa
<
	tT
>::
	ttu_t
eturn_t;

113 
le
 
tu_t
 
New
(
t32_t
 
vue
);

114 
le
 
tu_t
 
New
(
ut32_t
 
vue
);

117 
	gme
 <>

118 
	gFay
<
	gv8
::
Ieg
> : 
IegFay
<
v8
::Integer> {};

120 
	gme
 <>

121 
	gFay
<
	gv8
::
I32
> : 
IegFay
<
v8
::Int32> {};

123 
	gme
 <>

124 
	gFay
<
	gv8
::
Ut32
> : 
FayBa
<
v8
::Uint32> {

125 
le
 
tu_t
 
New
(
t32_t
 
vue
);

126 
le
 
tu_t
 
New
(
ut32_t
 
vue
);

129 
	gme
 <>

130 
	gFay
<
	gv8
::
Obje
> : 
FayBa
<
v8
::Object> {

131 
le
 
tu_t
 
New
();

134 
	gme
 <>

135 
	gFay
<
	gv8
::
ObjeTeme
> : 
FayBa
<
v8
::ObjectTemplate> {

136 
le
 
tu_t
 
New
();

139 
	gme
 <>

140 
	gFay
<
	gv8
::
RegExp
> : 
MaybeFayBa
<
v8
::RegExp> {

141 
le
 
tu_t
 
New
(

142 
v8
::
Lol
<v8::
Sg
> 
n
, v8::
RegExp
::
Fgs
 
ags
);

145 
	gme
 <>

146 
	gFay
<
	gv8
::
St
> : 
MaybeFayBa
<
v8
::Script> {

147 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour
);

148 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour


149 , 
v8
::
StOrig
 cڡ& 
ig
);

152 
	gme
 <>

153 
	gFay
<
	gv8
::
Sigtu
> : 
FayBa
<
v8
::Signature> {

154 
v8
::
	tLol
<
	tv8
::
	tFuniTeme
> 
	tFTH
;

155 
le
 
tu_t
 
New
(
FTH
 
iv
 = FTH());

158 
	gme
 <>

159 
	gFay
<
	gv8
::
Sg
> : 
MaybeFayBa
<
v8
::String> {

160 
le
 
tu_t
 
New
();

161 
le
 
tu_t
 
New
(cڡ *
vue
, 
ngth
 = -1);

162 
le
 
tu_t
 
New
(cڡ 
ut16_t
 *
vue
, 
ngth
 = -1);

163 
le
 
tu_t
 
New
(
d
::
rg
 cڡ& 
vue
);

165 
le
 
tu_t
 
New
(
v8
::
Sg
::
ExSgResour
 * 
vue
);

166 
le
 
tu_t
 
New
(
ExOBySgResour
 * 
vue
);

169 
	gme
 <>

170 
	gFay
<
	gv8
::
SgObje
> : 
FayBa
<
v8
::StringObject> {

171 
le
 
tu_t
 
New
(
v8
::
Lol
<v8::
Sg
> 
vue
);

176 #i(
NODE_MODULE_VERSION
 >= 12)

178 
mea
 
	gimp
 {

180 
	gme
 <>

181 
	gFay
<
	gv8
::
UnboundSt
> : 
MaybeFayBa
<
v8
::UnboundScript> {

182 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour
);

183 
le
 
tu_t
 
New

v8
::
Lol
<v8::
Sg
> 
sour


184 , 
v8
::
StOrig
 cڡ& 
ig
);

189 
	~"n_imemti_12_l.h
"

193 
	~"n_imemti_e_12_l.h
"

199 
	gme
 <
tyme
 
	gT
>

200 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


201 
	$New
() {

202  
imp
::
Fay
<
T
>::
	`New
();

203 
	}
}

205 
	gme
 <
tyme
 
	gT
,ym
	gA0
>

206 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


207 
	$New
(
A0
 
g0
) {

208  
imp
::
Fay
<
T
>::
	`New
(
g0
);

209 
	}
}

211 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
>

212 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


213 
	$New
(
A0
 
g0
, 
A1
 
g1
) {

214  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
);

215 
	}
}

217 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
,ym
	gA2
>

218 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


219 
	$New
(
A0
 
g0
, 
A1
 
g1
, 
A2
 
g2
) {

220  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
, 
g2
);

221 
	}
}

223 
	gme
 <
tyme
 
	gT
,ym
	gA0
,ym
	gA1
,ym
	gA2
,ym
	gA3
>

224 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


225 
	$New
(
A0
 
g0
, 
A1
 
g1
, 
A2
 
g2
, 
A3
 
g3
) {

226  
imp
::
Fay
<
T
>::
	`New
(
g0
, 
g1
, 
g2
, 
g3
);

227 
	}
}

235 
	gme
 <
tyme
 
	gT
>

236 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


237 
New

FuniClback
 
back


238 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()) {

239  
imp
::
Fay
<
T
>::
New
(
back
, 
da
);

243 
	gme
 <
tyme
 
	gT
,ym
	gA2
>

244 
tyme
 
	gimp
::
Fay
<
T
>::
tu_t


245 
New

FuniClback
 
back


246 , 
v8
::
Lol
<v8::
Vue
> 
da
 = v8::Local<v8::Value>()

247 , 
A2
 
a2
 = 
	$A2
()) {

248  
imp
::
Fay
<
T
>::
	`New
(
back
, 
da
, 
a2
);

249 
	}
}

253 #i
NODE_MODULE_VERSION
 < 
IOJS_3_0_MODULE_VERSION


254 
	gme
 <
tyme
 
	gT
> 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Hd
<T> 
h
);

257 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


258 
	gme
 <
tyme
 
	gT
,ym
	gM
>

259 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T, 
M
> cڡ& 
p
);

261 
	gme
 <
tyme
 
	gT
> 
le
 
	gv8
::
Lol
<
T
> 
New
(
v8
::
Psit
<T> cڡ& 
p
);

263 
	gme
 <
tyme
 
	gT
,ym
	gM
>

264 
le
 
	gv8
::
Lol
<
T
> 
New
(
Psit
<T, 
M
> cڡ& 
p
);

265 
	gme
 <
tyme
 
	gT
>

266 
le
 
	gv8
::
Lol
<
T
> 
New
(
Glob
<T> cڡ& 
p
);

268 
le


269 
	gimp
::
Fay
<
v8
::
Boޗn
>::
tu_t


270 
	$New
(
bo
 
vue
) {

271  
New
<
v8
::
Boޗn
>(
vue
);

272 
	}
}

274 
le


275 
	gimp
::
Fay
<
v8
::
I32
>::
tu_t


276 
	$New
(
t32_t
 
vue
) {

277  
New
<
v8
::
I32
>(
vue
);

278 
	}
}

280 
le


281 
	gimp
::
Fay
<
v8
::
Ut32
>::
tu_t


282 
	$New
(
ut32_t
 
vue
) {

283  
New
<
v8
::
Ut32
>(
vue
);

284 
	}
}

286 
le


287 
	gimp
::
Fay
<
v8
::
Numb
>::
tu_t


288 
	$New
(
vue
) {

289  
New
<
v8
::
Numb
>(
vue
);

290 
	}
}

292 
le


293 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


294 
	$New
(
d
::
rg
 cڡ& 
vue
) {

295  
New
<
v8
::
Sg
>(
vue
);

296 
	}
}

298 
le


299 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


300 
	$New
(cڡ * 
vue
, 
ngth
) {

301  
New
<
v8
::
Sg
>(
vue
, 
ngth
);

302 
	}
}

304 
le


305 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


306 
	$New
(cڡ 
ut16_t
 * 
vue
, 
ngth
) {

307  
New
<
v8
::
Sg
>(
vue
, 
ngth
);

308 
	}
}

310 
le


311 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


312 
	$New
(cڡ * 
vue
) {

313  
New
<
v8
::
Sg
>(
vue
);

314 
	}
}

316 
le


317 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


318 
	$New
(cڡ 
ut16_t
 * 
vue
) {

319  
New
<
v8
::
Sg
>(
vue
);

320 
	}
}

322 
le


323 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


324 
	$New
(
v8
::
Sg
::
ExSgResour
 * 
vue
) {

325  
New
<
v8
::
Sg
>(
vue
);

326 
	}
}

328 
le


329 
	gimp
::
Fay
<
v8
::
Sg
>::
tu_t


330 
	$New
(
ExOBySgResour
 * 
vue
) {

331  
New
<
v8
::
Sg
>(
vue
);

332 
	}
}

334 
le


335 
	gimp
::
Fay
<
v8
::
RegExp
>::
tu_t


336 
New
(
v8
::
Lol
<v8::
Sg
> 
n
, v8::
RegExp
::
Fgs
 
ags
) {

337  
New
<
v8
::
RegExp
>(
n
, 
	gags
);

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_object_wrap.h

9 #ide
NAN_OBJECT_WRAP_H_


10 
	#NAN_OBJECT_WRAP_H_


	)

12 as
	cObjeWp
 {

13 
	mpublic
:

14 
	$ObjeWp
() {

15 
fs_
 = 0;

19 
vtu
 ~
	$ObjeWp
() {

20 i(
	`rsit
().
	`IsEmy
()) {

24 
	`rsit
().
	`CˬWk
();

25 
	`rsit
().
	`Ret
();

26 
	}
}

29 
	gme
 <
ass
 
	gT
>

30 
le
 
T
* 
Unwp
(
v8
::
Lol
<v8::
Obje
> 
obje
) {

31 
as
(!
obje
.
IsEmy
());

32 
as
(
obje
->
IlFldCou
() > 0);

35 * 
	gr
 = 
GIlFldPor
(
obje
, 0);

36 
ObjeWp
* 
	gwp
 = 
ic_
<ObjeWp*>(
r
);

37  
	gic_
<
	gT
*>(
	gwp
);

41 
le
 
	gv8
::
Lol
<
v8
::
Obje
> 
	$hd
() const {

42  
	`New
(
hd_
);

43 
	}
}

46 
le
 
	gPsit
<
	gv8
::
Obje
>& 
	$rsit
() {

47  
hd_
;

48 
	}
}

51 
	geed
:

52 
le
 
Wp
(
v8
::
Lol
<v8::
Obje
> 
obje
) {

53 
as
(
rsit
().
IsEmy
());

54 
as
(
obje
->
IlFldCou
() > 0);

55 
SIlFldPor
(
obje
, 0, 
this
);

56 
rsit
().
Ret
(
obje
);

57 
MakeWk
();

60 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

61 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

63 
le
 
	$MakeWk
() {

64 
	`rsit
().
v8
::
PsitBa
<v8::
Obje
>::
	`SWk
(

65 
this
, 
WkClback
, 
v8
::
WkClbackTy
::
kPam
);

66 #i
NODE_MAJOR_VERSION
 < 10

68 
	`rsit
().
	`MkInddt
();

70 
	}
}

72 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


74 
le
 
	$MakeWk
() {

75 
	`rsit
().
v8
::
PsitBa
<v8::
Obje
>::
	`SWk
(
this
, 
WkClback
);

76 
	`rsit
().
	`MkInddt
();

77 
	}
}

81 
le
 
	$MakeWk
() {

82 
	`rsit
().
rsit
.
	`MakeWk
(
this
, 
WkClback
);

83 
	`rsit
().
	`MkInddt
();

84 
	}
}

92 
vtu
 
	$Ref
() {

93 
	`as
(!
	`rsit
().
	`IsEmy
());

94 
	`rsit
().
	`CˬWk
();

95 
fs_
++;

96 
	}
}

107 
vtu
 
	$Uef
() {

108 
	`as
(!
	`rsit
().
	`IsEmy
());

109 
	`as
(!
	`rsit
().
	`IsWk
());

110 
	`as
(
fs_
 > 0);

111 i(--
fs_
 == 0)

112 
	`MakeWk
();

113 
	}
}

115 
	gfs_
;

117 
	give
:

118 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
ObjeWp
)

119 #i
	`defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

120 (
V8_MAJOR_VERSION
 =4 && 
	`defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

123 
	`WkClback
(
v8
::
WkClbackInfo
<
ObjeWp
> cڡ& 
fo
) {

124 
ObjeWp
* 
wp
 = 
fo
.
	`GPam
();

125 
	`as
(
wp
->
fs_
 == 0);

126 
wp
->
hd_
.
	`Ret
();

127 
de
 
wp
;

128 
	}
}

130 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


133 
WkClback
(
v8
::
WkClbackDa
<v8::
Obje
, 
ObjeWp
> cڡ& 
da
) {

134 
ObjeWp
* 
	gwp
 = 
da
.
GPam
();

135 
as
(
wp
->
fs_
 == 0);

136 
as
(
wp
->
hd_
.
IsNrDth
());

137 
	gwp
->
	ghd_
.
Ret
();

138 
de
 
	gwp
;

143 
WkClback
(
v8
::
Psit
<v8::
Vue
> 
vue
, *
da
) {

144 
ObjeWp
 *
	gwp
 = 
ic_
<ObjeWp*>(
da
);

145 
as
(
wp
->
fs_
 == 0);

146 
as
(
wp
->
hd_
.
IsNrDth
());

147 
	gwp
->
	ghd_
.
Ret
();

148 
de
 
	gwp
;

152 
	gPsit
<
	gv8
::
Obje
> 
hd_
;

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_persistent_12_inl.h

9 #ide
NAN_PERSISTENT_12_INL_H_


10 
	#NAN_PERSISTENT_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
,ym
	gM
> 
ass
 
	gPsit
 :

13 
public
 
v8
::
Psit
<
T
, 
	gM
> {

14 
	gpublic
:

15 
le
 
Psit
(: 
v8
::Psit<
T
, 
	gM
>() {}

17 
	gme
<
tyme
 
	gS
> 
le
 
Psit
(
v8
::
Lol
<
S
> 
th
) :

18 
v8
::
Psit
<
T
, 
	gM
>(
	gv8
::
Isީe
::
GCut
(), 
	gth
) {}

20 
	gme
<
tyme
 
	gS
,ym
	gM2
>

21 
le


22 
Psit
(cڡ 
v8
::Psit<
S
, 
M2
> &
th
) :

23 
v8
::
Psit
<
T
, 
	gM2
>(
	gv8
::
Isީe
::
GCut
(), 
	gth
) {}

25 
le
 
Ret
({ 
	gv8
::
PsitBa
<
T
>::Reset(); }

27 
	gme
 <
tyme
 
	gS
>

28 
le
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

29 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

32 
	gme
 <
tyme
 
	gS
>

33 
le
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

34 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

37 
	gme
<
tyme
 
	gP
>

38 
le
 
SWk
(

39 
P
 *
m


40 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


41 , 
WkClbackTy
 
ty
);

43 
	give
:

44 
le
 
T
 *
ݔ
*(cڡ {  *
PsitBa
<T>::
rsit
; }

46 
	gme
<
tyme
 
	gS
,ym
	gM2
>

47 
le
 
Cy
(cڡ 
Psit
<
S
, 
M2
> &
th
) {

48 
TYPE_CHECK
(
T
, 
S
);

50 
	gthis
->
Ret
();

52 i(!
	gth
.
IsEmy
()) {

53 
	gthis
->
Ret
(
th
);

54 
	gM
::
Cy
(
th
, 
this
);

59 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

60 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

61 
me
<
tyme
 
T
>

62 
ass
 
Glob
 : 
public
 
v8
::Glob<
T
> {

63 
public
:

64 
le
 
Glob
(: 
v8
::Glob<
T
>() {}

66 
me
<
tyme
 
S
> 
le
 
Glob
(
v8
::
Lol
<S> 
th
) :

67 
v8
::
Glob
<
T
>(v8::
Isީe
::
GCut
(), 
th
) {}

69 
me
<
tyme
 
S
>

70 
le


71 
Glob
(cڡ 
v8
::
PsitBa
<
S
> &
th
) :

72 
v8
::
Glob
<
S
>(v8::
Isީe
::
GCut
(), 
th
) {}

74 
le
 
Ret
({ 
v8
::
PsitBa
<
T
>::Reset(); }

76 
	gme
 <
tyme
 
	gS
>

77 
le
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

78 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

81 
	gme
 <
tyme
 
	gS
>

82 
le
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

83 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

86 
	gme
<
tyme
 
	gP
>

87 
le
 
SWk
(

88 
P
 *
m


89 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


90 , 
WkClbackTy
 
ty
) {

91 
	gt_
<
	gPsit
<
	gT
>*>(
	gthis
)->
SWk
(

92 
m
, 
back
, 
ty
);

96 
	gme
<
tyme
 
	gT
>

97 
ass
 
	gGlob
 : 
public
 
v8
::
UniquePsit
<
T
> {

98 
public
:

99 
le
 
Glob
(: 
v8
::
UniquePsit
<
T
>() {}

101 
me
<
tyme
 
S
> 
le
 
Glob
(
v8
::
Lol
<S> 
th
) :

102 
v8
::
UniquePsit
<
T
>(v8::
Isީe
::
GCut
(), 
	gth
) {}

104 
	gme
<
tyme
 
	gS
>

105 
le


106 
Glob
(cڡ 
v8
::
PsitBa
<
S
> &
th
) :

107 
v8
::
UniquePsit
<
S
>(v8::
Isީe
::
GCut
(), 
	gth
) {}

109 
le
 
Ret
({ 
	gv8
::
PsitBa
<
T
>::Reset(); }

111 
	gme
 <
tyme
 
	gS
>

112 
le
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

113 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

116 
	gme
 <
tyme
 
	gS
>

117 
le
 
Ret
(cڡ 
v8
::
PsitBa
<
S
> &
h
) {

118 
v8
::
PsitBa
<
T
>::
Ret
(v8::
Isީe
::
GCut
(), 
h
);

121 
	gme
<
tyme
 
	gP
>

122 
le
 
SWk
(

123 
P
 *
m


124 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


125 , 
WkClbackTy
 
ty
) {

126 
	gt_
<
	gPsit
<
	gT
>*>(
	gthis
)->
SWk
(

127 
m
, 
back
, 
ty
);

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_persistent_pre_12_inl.h

9 #ide
NAN_PERSISTENT_PRE_12_INL_H_


10 
	#NAN_PERSISTENT_PRE_12_INL_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cPsitBa
 {

14 
	mv8
::
Psit
<
T
> 
rsit
;

15 
	mme
<
tyme
 
	mU
>

16 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
PsitBa
<U> &
p
);

17 
	mme
<
tyme
 
	mU
,ym
	mM
>

18 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
Psit
<U, 
M
> &
p
);

19 
	mme
<
tyme
 
	mU
>

20 
nd
 
	mv8
::
Lol
<
U
> 
New
(cڡ 
Glob
<U> &
p
);

21 
	mme
<
tyme
 
	mS
> 
nd
 
ass
 
	mRuVue
;

23 
	mpublic
:

24 
le
 
	$PsitBa
() :

25 
	$rsit
() {}

27 
le
 
	$Ret
() {

28 
rsit
.
	`Dio
();

29 
rsit
.
	`Cˬ
();

30 
	}
}

32 
	gme
<
tyme
 
	gS
>

33 
le
 
Ret
(cڡ 
v8
::
Lol
<
S
> &
h
) {

34 
TYPE_CHECK
(
T
, 
S
);

36 i(!
	grsit
.
IsEmy
()) {

37 
	grsit
.
Dio
();

40 i(
	gh
.
IsEmy
()) {

41 
	grsit
.
Cˬ
();

43 
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
h
);

47 
	gme
<
tyme
 
	gS
>

48 
le
 
Ret
(cڡ 
PsitBa
<
S
> &
h
) {

49 
TYPE_CHECK
(
T
, 
S
);

51 i(!
	grsit
.
IsEmy
()) {

52 
	grsit
.
Dio
();

55 i(
	gh
.
IsEmy
()) {

56 
	grsit
.
Cˬ
();

58 
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
h
.
rsit
);

62 
le
 
bo
 
	$IsEmy
(cڡ {  
rsit
.
	`IsEmy
(); 
	}
}

64 
le
 
	$Emy
({ 
rsit
.
	`Cˬ
(); 
	}
}

66 
	gme
<
tyme
 
	gS
>

67 
le
 
bo
 
	gݔ
==(cڡ 
PsitBa
<
S
> &
th
) const {

68  
this
->
rsit
 =
th
.persistent;

71 
	gme
<
tyme
 
	gS
>

72 
le
 
bo
 
	gݔ
==(cڡ 
v8
::
Lol
<
S
> &
th
) const {

73  
this
->
rsit
 =
th
;

76 
	gme
<
tyme
 
	gS
>

77 
le
 
bo
 
	gݔ
!=(cڡ 
PsitBa
<
S
> &
th
) const {

78  !
ݔ
==(
th
);

81 
	gme
<
tyme
 
	gS
>

82 
le
 
bo
 
	gݔ
!=(cڡ 
v8
::
Lol
<
S
> &
th
) const {

83  !
ݔ
==(
th
);

86 
	gme
<
tyme
 
	gP
>

87 
le
 
SWk
(

88 
P
 *
m


89 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


90 , 
WkClbackTy
 
ty
);

92 
le
 
	$CˬWk
({ 
rsit
.
	`CˬWk
(); 
	}
}

94 
le
 
	$MkInddt
({ 
rsit
.
	`MkInddt
(); 
	}
}

96 
le
 
bo
 
	$IsInddt
(cڡ {  
rsit
.
	`IsInddt
(); 
	}
}

98 
le
 
bo
 
	$IsNrDth
(cڡ {  
rsit
.
	`IsNrDth
(); 
	}
}

100 
le
 
bo
 
	$IsWk
(cڡ {  
rsit
.
	`IsWk
(); 
	}
}

102 
	give
:

103 
le
 
exic
 
PsitBa
(
v8
::
Psit
<
T
> 
th
) :

104 
	$rsit
(
th
{ 
	}
}

105 
le
 
exic
 
	$PsitBa
(
T
 *
v
: 
	$rsit
(
v
{
	}
}

106 
me
<
tyme
 
S
,ym
	gM
> 
nd
 
ass
 
	gPsit
;

107 
	gme
<
tyme
 
	gS
> 
nd
 
ass
 
	gGlob
;

108 
nd
 
ass
 
	gObjeWp
;

111 
	gme
<
tyme
 
	gT
>

112 as
	cNCyabPsitTs
 {

113 
	mpublic
:

114 
Psit
<
	tT
, 
	tNCyabPsitTs
<T> >

115 
	tNCyabPsit
;

116 cڡ 
bo
 
	mkRetInDeru
 = 
l
;

117 
	mme
<
tyme
 
	mS
,ym
	mM
>

118 
le
 
Cy
(cڡ 
Psit
<
S
, 
M
> &
sour
,

119 
NCyabPsit
 *
de
) {

120 
	mUncompab
<
	mv8
::
Obje
>();

123 
	gme
<
tyme
 
	gO
> 
le
 
	$Uncompab
() {

124 
	`TYPE_CHECK
(
O
, 
v8
::
Primive
);

125 
	}
}

128 
	gme
<
tyme
 
	gT
>

129 
	sCyabPsitTs
 {

130 
	mPsit
<
	tT
, 
	tCyabPsitTs
<T> > 
	tCyabPsit
;

131 cڡ 
bo
 
	mkRetInDeru
 = 
ue
;

132 
	mme
<
tyme
 
	mS
,ym
	mM
>

133 
le
 
Cy
(cڡ 
Psit
<
S
, 
M
> &
sour
,

134 
CyabPsit
 *
de
) {}

137 
	gme
<
tyme
 
	gT
,ym
	gM
> 
ass
 
	gPsit
 :

138 
public
 
PsitBa
<
T
> {

139 
public
:

140 
le
 
Psit
() {}

142 
me
<
tyme
 
S
> 
le
 
Psit
(
v8
::
Hd
<S> 
th
)

143 : 
PsitBa
<
T
>(
v8
::
Psit
<T>::
New
(
th
)) {

144 
TYPE_CHECK
(
T
, 
S
);

147 
le
 
Psit
(cڡ Psi&
th
: 
PsitBa
<
T
>() {

148 
Cy
(
th
);

151 
	gme
<
tyme
 
	gS
,ym
	gM2
>

152 
le
 
Psit
(cڡ Psit<
S
, 
M2
> &
th
) :

153 
PsitBa
<
T
>() {

154 
Cy
(
th
);

157 
le
 
	gPsit
 &
	gݔ
=(cڡ 
Psit
 &
th
) {

158 
Cy
(
th
);

159  *
	gthis
;

162 
	gme
 <
ass
 
	gS
, cs
	gM2
>

163 
le
 
	gPsit
 &
	gݔ
=(cڡ 
Psit
<
S
, 
	gM2
> &
	gth
) {

164 
Cy
(
th
);

165  *
	gthis
;

168 
	gle
 ~
Psit
() {

169 i(
	gM
::
kRetInDeru

this
->
Ret
();

172 
	give
:

173 
le
 
T
 *
ݔ
*(cڡ {  *
PsitBa
<T>::
rsit
; }

175 
	gme
<
tyme
 
	gS
,ym
	gM2
>

176 
le
 
Cy
(cڡ 
Psit
<
S
, 
M2
> &
th
) {

177 
TYPE_CHECK
(
T
, 
S
);

179 
	gthis
->
Ret
();

181 i(!
	gth
.
IsEmy
()) {

182 
	gthis
->
	grsit
 = 
v8
::
Psit
<
T
>::
New
(
th
.
rsit
);

183 
	gM
::
Cy
(
th
, 
this
);

188 
	gme
<
tyme
 
	gT
>

189 
ass
 
	gGlob
 : 
public
 
PsitBa
<
T
> {

190 
	sRVue
 {

191 
le
 
exic
 
RVue
(
Glob
* 
obj
: 
obje
(obj) {}

192 
Glob
* 
obje
;

195 
	gpublic
:

196 
le
 
Glob
(: 
PsitBa
<
T
>(0) { }

198 
me
 <
tyme
 
S
>

199 
le
 
Glob
(
v8
::
Lol
<
S
> 
th
)

200 : 
PsitBa
<
T
>(
v8
::
Psit
<T>::
New
(
th
)) {

201 
TYPE_CHECK
(
T
, 
S
);

204 
	gme
 <
tyme
 
	gS
>

205 
le
 
Glob
(cڡ 
PsitBa
<
S
> &
th
)

206 : 
PsitBa
<
T
>(
th
) {

207 
TYPE_CHECK
(
T
, 
S
);

212 
le
 
Glob
(
RVue
 
rvue
)

213 : 
PsitBa
<
T
>(
rvue
.
obje
->
rsit
) {

214 
rvue
.
obje
->
Ret
();

216 
	gle
 ~
Glob
({ 
	gthis
->
Ret
(); }

220 
	gme
<
tyme
 
	gS
>

221 
le
 
	gGlob
 &
	gݔ
=(
Glob
<
S
> 
rhs
) {

222 
TYPE_CHECK
(
T
, 
S
);

223 
	gthis
->
Ret
(
rhs
.
rsit
);

224 
	grhs
.
Ret
();

225  *
	gthis
;

230 
le
 
ݔ
 
RVue
({  RVue(
this
); }

234 
Glob
 
Pass
({  Glob(
RVue
(
this
)); }

236 
	give
:

237 
Glob
(Global &);

238 
	gݔ
=(
Glob
 &);

239 
	gme
<
tyme
 
	gS
> 
nd
 
ass
 
	gRuVue
;

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_private.h

9 #ide
NAN_PRIVATE_H_


10 
	#NAN_PRIVATE_H_


	)

12 
le
 
	gMaybe
<
	gbo
>

13 
HasPrive
(
v8
::
Lol
<v8::
Obje
> 
obje
, v8::Lol<v8::
Sg
> 
key
) {

14 
HdSce
 
sce
;

15 #i
NODE_MODULE_VERSION
 >
NODE_6_0_MODULE_VERSION


16 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

17 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
cڋxt
 = 
isީe
->
GCutCڋxt
();

18 
	gv8
::
Lol
<
v8
::
Prive
> 
ive_key
 = v8::Prive::
FApi
(
isީe
, 
key
);

19  
	gobje
->
HasPrive
(
cڋxt
, 
ive_key
);

21  
Ju
(!
obje
->
GHiddVue
(
key
).
IsEmy
());

25 
le
 
	gMaybeLol
<
	gv8
::
Vue
>

26 
GPrive
(
v8
::
Lol
<v8::
Obje
> 
obje
, v8::Lol<v8::
Sg
> 
key
) {

27 #i
NODE_MODULE_VERSION
 >
NODE_6_0_MODULE_VERSION


28 
v8
::
Isީe
 *
isީe
 = v8::Isީe::
GCut
();

29 
	gv8
::
EsbHdSce
 
sce
(
isީe
);

30 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
cڋxt
 = 
isީe
->
GCutCڋxt
();

31 
	gv8
::
Lol
<
v8
::
Prive
> 
ive_key
 = v8::Prive::
FApi
(
isީe
, 
key
);

32 
	gv8
::
MaybeLol
<
v8
::
Vue
> 
v
 = 
obje
->
GPrive
(
cڋxt
, 
ive_key
);

33  
	gsce
.
Es
(
v
.
ToLolChecked
());

35 
EsbHdSce
 
	gsce
;

36 
	gv8
::
Lol
<
v8
::
Vue
> 
v
 = 
obje
->
GHiddVue
(
key
);

37 i(
	gv
.
IsEmy
()) {

38 
	gv
 = 
Undefed
();

40  
	gsce
.
Es
(
v
);

44 
le
 
	gMaybe
<
	gbo
> 
SPrive
(

45 
v8
::
Lol
<v8::
Obje
> 
obje
,

46 
v8
::
Lol
<v8::
Sg
> 
key
,

47 
v8
::
Lol
<v8::
Vue
> 
vue
) {

48 #i
NODE_MODULE_VERSION
 >
NODE_6_0_MODULE_VERSION


49 
HdSce
 
sce
;

50 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

51 
	gv8
::
Lol
<
v8
::
Cڋxt
> 
cڋxt
 = 
isީe
->
GCutCڋxt
();

52 
	gv8
::
Lol
<
v8
::
Prive
> 
ive_key
 = v8::Prive::
FApi
(
isީe
, 
key
);

53  
	gobje
->
SPrive
(
cڋxt
, 
ive_key
, 
vue
);

55  
Ju
(
obje
->
SHiddVue
(
key
, 
vue
));

59 
le
 
	gMaybe
<
	gbo
> 
DePrive
(

60 
v8
::
Lol
<v8::
Obje
> 
obje
,

61 
v8
::
Lol
<v8::
Sg
> 
key
) {

62 #i
NODE_MODULE_VERSION
 >
NODE_6_0_MODULE_VERSION


63 
HdSce
 
sce
;

64 
	gv8
::
Isީe
 *
isީe
 = 
v8
::Isީe::
GCut
();

65 
	gv8
::
Lol
<
v8
::
Prive
> 
ive_key
 = v8::Prive::
FApi
(
isީe
, 
key
);

66  
	gobje
->
DePrive
(
isީe
->
GCutCڋxt
(), 
ive_key
);

68  
Ju
(
obje
->
DeHiddVue
(
key
));

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_string_bytes.h

22 #ide
NAN_STRING_BYTES_H_


23 
	#NAN_STRING_BYTES_H_


	)

27 
mea
 
	gimp
 {

29 
usg
 
	gv8
::
Lol
;

30 
usg
 
	gv8
::
Obje
;

31 
usg
 
	gv8
::
Sg
;

32 
usg
 
	gv8
::
Vue
;

37 
	#ba64_coded_size
(
size
((siz+ 2 - ((siz+ 2% 3)/ 3 * 4)

	)

43 
bo
 
cڏs_n_ascii_ow
(cڡ * 
buf
, 
size_t
 
n
) {

44 
size_t
 
	gi
 = 0; i < 
	gn
; ++i) {

45 i(
	gbuf
[
i
] & 0x80 
	gue
;

47  
	gl
;

51 
bo
 
cڏs_n_ascii
(cڡ * 
c
, 
size_t
 
n
) {

52 i(
	gn
 < 16) {

53  
cڏs_n_ascii_ow
(
c
, 
n
);

56 cڡ 
	gbys_r_wd
 = (*);

57 cڡ 
	gign_mask
 = 
bys_r_wd
 - 1;

58 cڡ 
	guligd
 = 
t_
<
u_t
>(
c
& 
ign_mask
;

60 i(
	guligd
 > 0) {

61 cڡ 
	gn
 = 
bys_r_wd
 - 
uligd
;

62 i(
cڏs_n_ascii_ow
(
c
, 
n
) 
	gue
;

63 
	gc
 +
n
;

64 
	gn
 -
n
;

68 #i
defed
(
__x86_64__
|| defed(
_WIN64
)

69 cڡ 
u_t
 
	gmask
 = 0x8080808080808080ll;

71 cڡ 
u_t
 
	gmask
 = 0x80808080l;

74 cڡ 
u_t
* 
	gcw
 = 
t_
<cڡ u_t*>(
c
);

76 
size_t
 
	gi
 = 0, 
	gn
 = 
n
 / 
bys_r_wd
; i <; ++i) {

77 i(
	gcw
[
i
] & 
	gmask
 
	gue
;

80 cڡ 
	gmad
 = 
n
 & 
ign_mask
;

81 i(
	gmad
 > 0) {

82 cڡ 
size_t
 
	gofft
 = 
n
 - 
mad
;

83 i(
cڏs_n_ascii_ow
(
c
 + 
offt
, 
mad
) 
	gue
;

86  
	gl
;

90 
f_ascii_ow
(cڡ * 
c
, * 
d
, 
size_t
 
n
) {

91 
size_t
 
	gi
 = 0; i < 
	gn
; ++i) {

92 
	gd
[
i
] = 
c
[i] & 0x7f;

97 
f_ascii
(cڡ * 
c
, * 
d
, 
size_t
 
n
) {

98 i(
	gn
 < 16) {

99 
f_ascii_ow
(
c
, 
d
, 
n
);

103 cڡ 
	gbys_r_wd
 = (*);

104 cڡ 
	gign_mask
 = 
bys_r_wd
 - 1;

105 cڡ 
	gc_ulign
 = 
t_
<
u_t
>(
c
& 
ign_mask
;

106 cڡ 
	gd_ulign
 = 
t_
<
u_t
>(
d
& 
ign_mask
;

108 i(
	gc_ulign
 > 0) {

109 i(
	gc_ulign
 =
d_ulign
) {

110 cڡ 
ulign
 = 
bys_r_wd
 - 
c_ulign
;

111 
f_ascii_ow
(
c
, 
d
, 
ulign
);

112 
	gc
 +
ulign
;

113 
	gd
 +
ulign
;

114 
	gn
 -
c_ulign
;

116 
f_ascii_ow
(
c
, 
d
, 
n
);

121 #i
defed
(
__x86_64__
|| defed(
_WIN64
)

122 cڡ 
u_t
 
	gmask
 = ~0x8080808080808080ll;

124 cڡ 
u_t
 
	gmask
 = ~0x80808080l;

127 cڡ 
u_t
* 
	gcw
 = 
t_
<cڡ u_t*>(
c
);

128 
u_t
* 
	gdw
 = 
t_
<u_t*>(
d
);

130 
size_t
 
	gi
 = 0, 
	gn
 = 
n
 / 
bys_r_wd
; i <; ++i) {

131 
	gdw
[
i
] = 
cw
[i] & 
mask
;

134 cڡ 
	gmad
 = 
n
 & 
ign_mask
;

135 i(
	gmad
 > 0) {

136 cڡ 
size_t
 
	gofft
 = 
n
 - 
mad
;

137 
f_ascii_ow
(
c
 + 
offt
, 
d
 + offt, 
mad
);

142 
size_t
 
ba64_code
(cڡ * 
c
,

143 
size_t
 

,

144 * 
d
,

145 
size_t
 
dn
) {

147 
as
(
dn
 >
ba64_coded_size
(

) &&

150 
	gdn
 = 
ba64_coded_size
(

);

152 
	ga
;

153 
	gb
;

154 
	gc
;

155 
	gi
;

156 
	gk
;

157 
	gn
;

159 cڡ 
	gb
[] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ"

163 
	gi
 = 0;

164 
	gk
 = 0;

165 
	gn
 = 

 / 3 * 3;

167 
	gi
 < 
	gn
) {

168 
	ga
 = 
c
[
i
 + 0] & 0xff;

169 
	gb
 = 
c
[
i
 + 1] & 0xff;

170 
	gc
 = 
c
[
i
 + 2] & 0xff;

172 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

173 
	gd
[
k
 + 1] = 
b
[((
a
 & 3<< 4| (
b
 >> 4)];

174 
	gd
[
k
 + 2] = 
b
[((
b
 & 0x0f<< 2| (
c
 >> 6)];

175 
	gd
[
k
 + 3] = 
b
[
c
 & 0x3f];

177 
	gi
 += 3;

178 
	gk
 += 4;

181 i(
	gn
 !

) {

182 

 - 
n
) {

184 
a
 = 
c
[
i
 + 0] & 0xff;

185 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

186 
	gd
[
k
 + 1] = 
b
[(
a
 & 3) << 4];

187 
	gd
[
k
 + 2] = '=';

188 
	gd
[
k
 + 3] = '=';

192 
a
 = 
c
[
i
 + 0] & 0xff;

193 
	gb
 = 
c
[
i
 + 1] & 0xff;

194 
	gd
[
k
 + 0] = 
b
[
a
 >> 2];

195 
	gd
[
k
 + 1] = 
b
[((
a
 & 3<< 4| (
b
 >> 4)];

196 
	gd
[
k
 + 2] = 
b
[(
b
 & 0x0f) << 2];

197 
	gd
[
k
 + 3] = '=';

202  
	gdn
;

206 
size_t
 
hex_code
(cڡ * 
c
, size_

, * 
d
, size_
dn
) {

208 
as
(
dn
 >

 * 2 &&

211 
	gdn
 = 

 * 2;

212 
ut32_t
 
	gi
 = 0, 
	gk
 = 0; k < 
	gdn
; i += 1, k += 2) {

213 cڡ 
hex
[] = "0123456789abcdef";

214 
ut8_t
 
	gv
 = 
ic_
<ut8_t>(
c
[
i
]);

215 
	gd
[
k
 + 0] = 
hex
[
v
 >> 4];

216 
	gd
[
k
 + 1] = 
hex
[
v
 & 15];

219  
	gdn
;

224 
	gLol
<
	gVue
> 
Encode
(cڡ * 
buf
,

225 
size_t
 
bu
,

226 
Encodg
 
codg
) {

227 
as
(
bu
 <
node
::
Bufr
::
kMaxLgth
);

228 i(!
	gbu
 && 
	gcodg
 !
BUFFER
)

229  
New
("").
ToLolChecked
();

231 
	gLol
<
	gSg
> 
	gv
;

232 
	gcodg
) {

233 
	gBUFFER
:

234  
CyBufr
(
buf
, 
bu
).
ToLolChecked
();

236 
	gASCII
:

237 i(
cڏs_n_ascii
(
buf
, 
bu
)) {

238 * 
	gout
 = 
w
 [
bu
];

239 
f_ascii
(
buf
, 
out
, 
bu
);

240 
	gv
 = 
New
<
Sg
>(
out
, 
	gbu
).
ToLolChecked
();

241 
	gde
[] 
	gout
;

243 
	gv
 = 
New
<
Sg
>(
buf
, 
	gbu
).
ToLolChecked
();

247 
	gUTF8
:

248 
v
 = 
New
<
Sg
>(
buf
, 
	gbu
).
ToLolChecked
();

251 
	gBINARY
: {

253 cڡ *
cbuf
 = 
t_
<cڡ *>(
buf
);

254 
ut16_t
 * 
	gtwobybuf
 = 
w
 ut16_t[
bu
];

255 
size_t
 
	gi
 = 0; i < 
	gbu
; i++) {

257 
	gtwobybuf
[
i
] = 
cbuf
[i];

259 
	gv
 = 
New
<
Sg
>(
twobybuf
, 
	gbu
).
ToLolChecked
();

260 
	gde
[] 
	gtwobybuf
;

264 
	gBASE64
: {

265 
size_t
 
dn
 = 
ba64_coded_size
(
bu
);

266 * 
	gd
 = 
w
 [
dn
];

268 
size_t
 
	gwrn
 = 
ba64_code
(
buf
, 
bu
, 
d
, 
dn
);

269 
as
(
wrn
 =
dn
);

271 
	gv
 = 
New
<
Sg
>(
d
, 
	gdn
).
ToLolChecked
();

272 
	gde
[] 
	gd
;

276 
	gUCS2
: {

277 cڡ 
ut16_t
* 
da
 = 
t_
<cڡ ut16_t*>(
buf
);

278 
	gv
 = 
New
<
Sg
>(
da
, 
	gbu
 / 2).
ToLolChecked
();

282 
	gHEX
: {

283 
size_t
 
dn
 = 
bu
 * 2;

284 * 
	gd
 = 
w
 [
dn
];

285 
size_t
 
	gwrn
 = 
hex_code
(
buf
, 
bu
, 
d
, 
dn
);

286 
as
(
wrn
 =
dn
);

288 
	gv
 = 
New
<
Sg
>(
d
, 
	gdn
).
ToLolChecked
();

289 
	gde
[] 
	gd
;

294 
as
(0 && "unknownncoding");

298  
	gv
;

301 #unde
ba64_coded_size


	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_typedarray_contents.h

9 #ide
NAN_TYPEDARRAY_CONTENTS_H_


10 
	#NAN_TYPEDARRAY_CONTENTS_H_


	)

12 
	gme
<
tyme
 
	gT
>

13 as
	cTydAayCڋs
 {

14 
	mpublic
:

15 
le
 
exic
 
TydAayCڋs
(
v8
::
Lol
<v8::
Vue
> 
om
) :

16 
ngth_
(0), 
	$da_
(
NULL
) {

17 
HdSce
 
sce
;

19 
size_t
 
ngth
 = 0;

20 * 
da
 = 
NULL
;

22 #i
	`defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

23 (
V8_MAJOR_VERSION
 =4 && 
	`defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

25 i(
om
->
	`IsAayBufrVw
()) {

26 
v8
::
Lol
<v8::
AayBufrVw
> 
y
 =

27 
v8
::
Lol
<v8::
AayBufrVw
>::
	`Ca
(
om
);

29 cڡ 
size_t
 
by_ngth
 = 
y
->
	`ByLgth
();

30 cڡ 
rdiff_t
 
by_offt
 = 
y
->
	`ByOfft
();

31 
v8
::
Lol
<v8::
AayBufr
> 
bufr
 = 
y
->
	`Bufr
();

33 
ngth
 = 
by_ngth
 / (
T
);

36 #i(
V8_MAJOR_VERSION
 >= 8)

37 
da
 = 
ic_
<*>(
bufr
->
	`GBackgSte
()->
	`Da
()+ 
by_offt
;

39 
da
 = 
ic_
<*>(
bufr
->
	`GCڋs
().
	`Da
()+ 
by_offt
;

45 i(
om
->
	`IsObje
(&& !om->
	`IsNu
()) {

46 
v8
::
Lol
<v8::
Obje
> 
y
 = v8::Lol<v8::Obje>::
	`Ca
(
om
);

48 
MaybeLol
<
v8
::
Vue
> 
bufr
 = 
	`G
(
y
,

49 
New
<
v8
::
Sg
>("bufr").
	`ToLolChecked
());

50 
MaybeLol
<
v8
::
Vue
> 
by_ngth
 = 
	`G
(
y
,

51 
New
<
v8
::
Sg
>("byLgth").
	`ToLolChecked
());

52 
MaybeLol
<
v8
::
Vue
> 
by_offt
 = 
	`G
(
y
,

53 
New
<
v8
::
Sg
>("byOfft").
	`ToLolChecked
());

55 i(!
bufr
.
	`IsEmy
() &&

56 !
by_ngth
.
	`IsEmy
(&& by_ngth.
	`ToLolChecked
()->
	`IsUt32
() &&

57 !
by_offt
.
	`IsEmy
(&& by_offt.
	`ToLolChecked
()->
	`IsUt32
()) {

58 
da
 = 
y
->
	`GIndexedPrݔtsExAayDa
();

59 if(
da
) {

60 
ngth
 = 
by_ngth
.
	`ToLolChecked
()->
	`Ut32Vue
(/ (
T
);

67 #i
	`defed
(
_MSC_VER
&& _MSC_VER >1900 || 
__lulus
 >= 201103L

68 
	`as
(
t_
<
u_t
>(
da
% 
	`ignof
 (
T
) == 0);

69 #i
	`defed
(
_MSC_VER
&& _MSC_VER >1600 || defed(
__GNUC__
)

70 
	`as
(
t_
<
u_t
>(
da
% 
	`__ignof
(
T
) == 0);

72 
	`as
(
t_
<
u_t
>(
da
%  (
T
) == 0);

75 
ngth_
 = 
ngth
;

76 
da_
 = 
ic_
<
T
*>(
da
);

79 
le
 
size_t
 
	$ngth
(cڡ {  
ngth_
; 
	}
}

80 
le
 
T
* 
	gݔ
*({  
	gda_
; }

81 
le
 cڡ 
T
* 
	gݔ
*(cڡ {  
	gda_
; }

83 
	give
:

84 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
TydAayCڋs
)

87 *
ݔ
 
	`w
(
size_t
 
size
);

88 
ݔ
 
	$de
(*, 
size_t
) {

89 
	`abt
();

90 
	}
}

92 
size_t
 
	gngth_
;

93 
T
* 
	gda_
;

	@/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_weak.h

9 #ide
NAN_WEAK_H_


10 
	#NAN_WEAK_H_


	)

12 cڡ 
	gkIlFldsInWkClback
 = 2;

13 cڡ 
	gkNoIlFldIndex
 = -1;

15 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

16 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

17 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

18 
v8
::
WkClbackInfo
<WkClbackInfo<
T
> > cڡ&

	)

19 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

20 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

21 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

22 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

23 #i
NODE_MODULE_VERSION
 > 
IOJS_1_1_MODULE_VERSION


24 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

25 
v8
::
PhtomClbackDa
<
WkClbackInfo
<
T
> > cڡ&

	)

26 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

27 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

28 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

29 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

30 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


31 
	#NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 \

32 
v8
::
PhtomClbackDa
<
WkClbackInfo
<
T
> > cڡ&

	)

33 
	#NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 \

34 
v8
::
IlFldsClbackDa
<
WkClbackInfo
<
T
>, > cڡ&

	)

35 
	#NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


	)

36 
	#NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


	)

37 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


38 
	#NAN_WEAK_CALLBACK_DATA_TYPE_
 \

39 
v8
::
WkClbackDa
<
S
, 
WkClbackInfo
<
T
> > cڡ&

	)

40 
	#NAN_WEAK_CALLBACK_SIG_
 
NAN_WEAK_CALLBACK_DATA_TYPE_


	)

42 
	#NAN_WEAK_CALLBACK_DATA_TYPE_
 *

	)

43 
	#NAN_WEAK_CALLBACK_SIG_
 \

44 
v8
::
Psit
<v8::
Vue
>, 
NAN_WEAK_CALLBACK_DATA_TYPE_


	)

47 
	gme
<
tyme
 
	gT
>

48 as
	cWkClbackInfo
 {

49 
	mpublic
:

50 (*
	tClback
)(cڡ 
	tWkClbackInfo
<
	tT
>& 
	tda
);

51 
	`WkClbackInfo
(

52 
Psit
<
v8
::
Vue
> *
rsit


53 , 
Clback
 
back


54 , *
m


55 , *
fld1
 = 0

56 , *
fld2
 = 0) :

57 
	`back_
(
back
), 
	`isީe_
(0), 
	$m_
(
m
) {

58 
d
::
	`memy
(&
rsit_
, 
rsit
,  (
v8
::
Psit
<v8::
Vue
>));

59 
_flds_
[0] = 
fld1
;

60 
_flds_
[1] = 
fld2
;

62 
le
 
v8
::
Isީe
 *
	$GIsީe
(cڡ {  
isީe_
; 
	}
}

63 
le
 
T
 *
	$GPam
(cڡ {  
ic_
<
T
*>(
m_
); 
	}
}

64 
le
 *
	$GIlFld
(
dex
) const {

65 
	`as
((
dex
 == 0 || index == 1) && "internal field index out of bounds");

66 i(
dex
 == 0) {

67  
_flds_
[0];

69  
_flds_
[1];

71 
	}
}

73 
	give
:

74 
	$NAN_DISALLOW_ASSIGN_COPY_MOVE
(
WkClbackInfo
)

75 
Clback
 
back_
;

76 
v8
::
Isީe
 *
isީe_
;

77 *
m_
;

78 *
_flds_
[
kIlFldsInWkClback
];

79 
v8
::
Psit
<v8::
Vue
> 
rsit_
;

80 
me
<
tyme
 
S
,ym
M
> 
nd
 
ass
 
Psit
;

81 
me
<
tyme
 
S
> 
nd
 
ass
 
PsitBa
;

82 #i
NODE_MODULE_VERSION
 <
NODE_0_12_MODULE_VERSION


83 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


84 
me
<
tyme
 
S
>

85 
	`voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
);

86 
me
<
tyme
 
S
>

87 
WkClbackInfo
 *
	`unwp
(
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
);

89 
	`voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
);

90 
WkClbackInfo
 *
	`unwp
(
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
);

93 #i
	`defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

94 (
V8_MAJOR_VERSION
 =4 && 
	`defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

95 
me
<
bo
 
isFPass
>

96 
	`vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
);

97 
me
<
bo
 
isFPass
>

98 
	`vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
);

100 
	`vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
);

101 
	`vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
);

103 
WkClbackInfo
 *
	`unwam
(

104 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
);

105 
WkClbackInfo
 *
	`unwwofld
(

106 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
);

108 
	}
};

111 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

112 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

114 
me
<
tyme
 
T
>

115 
me
<
bo
 
isFPass
>

117 
WkClbackInfo
<
T
>::
	$vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
) {

118 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwam
(
da
);

119 i(
isFPass
) {

120 
cbfo
->
rsit_
.
	`Ret
();

121 
da
.
	`SSecdPassClback
(
vokam
<
l
>);

123 
cbfo
->
	`back_
(*cbinfo);

124 
de
 
cbfo
;

126 
	}
}

128 
	gme
<
tyme
 
	gT
>

129 
	gme
<
bo
 
	gisFPass
>

131 
	gWkClbackInfo
<
	gT
>::
	$vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
) {

132 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwwofld
(
da
);

133 i(
isFPass
) {

134 
cbfo
->
rsit_
.
	`Ret
();

135 
da
.
	`SSecdPassClback
(
vokwofld
<
l
>);

137 
cbfo
->
	`back_
(*cbinfo);

138 
de
 
cbfo
;

140 
	}
}

142 
	gme
<
tyme
 
	gT
>

143 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwam
(

144 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
) {

145 
WkClbackInfo
<
T
> *
cbfo
 =

146 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GPam
());

147 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

148  
cbfo
;

149 
	}
}

151 
	gme
<
tyme
 
	gT
>

152 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwwofld
(

153 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
) {

154 
WkClbackInfo
<
T
> *
cbfo
 =

155 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GIlFld
(0));

156 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

157  
cbfo
;

158 
	}
}

160 #unde
NAN_WEAK_PARAMETER_CALLBACK_SIG_


161 #unde
NAN_WEAK_TWOFIELD_CALLBACK_SIG_


162 #unde
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


163 #unde
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


164 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


166 
	gme
<
tyme
 
	gT
>

168 
	gWkClbackInfo
<
	gT
>::
	$vokam
(
NAN_WEAK_PARAMETER_CALLBACK_SIG_
 
da
) {

169 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwam
(
da
);

170 
cbfo
->
rsit_
.
	`Ret
();

171 
cbfo
->
	`back_
(*cbinfo);

172 
de
 
cbfo
;

173 
	}
}

175 
	gme
<
tyme
 
	gT
>

177 
	gWkClbackInfo
<
	gT
>::
	$vokwofld
(
NAN_WEAK_TWOFIELD_CALLBACK_SIG_
 
da
) {

178 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwwofld
(
da
);

179 
cbfo
->
rsit_
.
	`Ret
();

180 
cbfo
->
	`back_
(*cbinfo);

181 
de
 
cbfo
;

182 
	}
}

184 
	gme
<
tyme
 
	gT
>

185 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwam
(

186 
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_
 
da
) {

187 
WkClbackInfo
<
T
> *
cbfo
 =

188 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GPam
());

189 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

190  
cbfo
;

191 
	}
}

193 
	gme
<
tyme
 
	gT
>

194 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwwofld
(

195 
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_
 
da
) {

196 
WkClbackInfo
<
T
> *
cbfo
 =

197 
ic_
<
WkClbackInfo
<
T
>*>(
da
.
	`GIlFld1
());

198 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

199  
cbfo
;

200 
	}
}

202 #unde
NAN_WEAK_PARAMETER_CALLBACK_SIG_


203 #unde
NAN_WEAK_TWOFIELD_CALLBACK_SIG_


204 #unde
NAN_WEAK_PARAMETER_CALLBACK_DATA_TYPE_


205 #unde
NAN_WEAK_TWOFIELD_CALLBACK_DATA_TYPE_


206 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


208 
	gme
<
tyme
 
	gT
>

209 
	gme
<
tyme
 
	gS
>

210 
	gWkClbackInfo
<
	gT
>::
	$voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
) {

211 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwp
(
da
);

212 
cbfo
->
rsit_
.
	`Ret
();

213 
cbfo
->
	`back_
(*cbinfo);

214 
de
 
cbfo
;

215 
	}
}

217 
	gme
<
tyme
 
	gT
>

218 
	gme
<
tyme
 
	gS
>

219 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwp
(

220 
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
) {

221 *
m
 = 
da
.
	`GPam
();

222 
WkClbackInfo
<
T
> *
cbfo
 =

223 
ic_
<
WkClbackInfo
<
T
>*>(
m
);

224 
cbfo
->
isީe_
 = 
da
.
	`GIsީe
();

225  
cbfo
;

226 
	}
}

228 #unde
NAN_WEAK_CALLBACK_SIG_


229 #unde
NAN_WEAK_CALLBACK_DATA_TYPE_


232 
	gme
<
tyme
 
	gT
>

233 
	gWkClbackInfo
<
	gT
>::
	$voke
(
NAN_WEAK_CALLBACK_SIG_
 
da
) {

234 
WkClbackInfo
<
T
> *
cbfo
 = 
	`unwp
(
da
);

235 
cbfo
->
rsit_
.
	`Dio
();

236 
cbfo
->
rsit_
.
	`Cˬ
();

237 
cbfo
->
	`back_
(*cbinfo);

238 
de
 
cbfo
;

239 
	}
}

241 
	gme
<
tyme
 
	gT
>

242 
	gWkClbackInfo
<
	gT
> *WkClbackInfo<T>::
	$unwp
(

243 
NAN_WEAK_CALLBACK_DATA_TYPE_
 
da
) {

244 
WkClbackInfo
<
T
> *
cbfo
 =

245 
ic_
<
WkClbackInfo
<
T
>*>(
da
);

246 
cbfo
->
isީe_
 = 
v8
::
Isީe
::
	`GCut
();

247  
cbfo
;

248 
	}
}

250 #unde
NAN_WEAK_CALLBACK_SIG_


251 #unde
NAN_WEAK_CALLBACK_DATA_TYPE_


254 #i
defed
(
V8_MAJOR_VERSION
) && (V8_MAJOR_VERSION > 4 || \

255 (
	gV8_MAJOR_VERSION
 =4 && 
defed
(
V8_MINOR_VERSION
) && V8_MINOR_VERSION >= 3))

256 
me
<
tyme
 
T
,ym
	gM
>

257 
	gme
<
tyme
 
	gP
>

258 
le
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

259 
P
 *
m


260 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


261 , 
WkClbackTy
 
ty
) {

262 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

263 i(
	gty
 =
WkClbackTy
::
kPam
) {

264 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

265 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

266 , 
	gback


267 , 
	gm
);

268 
	gv8
::
PsitBa
<
T
>::
SWk
(

269 
wcbd


270 , 
WkClbackInfo
<
P
>::
me
 
vokam
<
ue
>

271 , 
ty
);

273 
	gv8
::
Lol
<
v8
::
Vue
>* 
lf_v
(
t_
<v8::Lol<v8::Vue>*>(
this
));

274 
as
((*
lf_v
)->
IsObje
());

275 
	gv8
::
Lol
<
v8
::
Obje
> 
lf
((*
lf_v
).
As
<v8::Object>());

276 
	gcou
 = 
lf
->
IlFldCou
();

277 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

278 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

279 
	g_flds
[
i
] = 
lf
->
GAligdPorFromIlFld
(i);

281 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

282 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

283 , 
	gback


285 , 
	g_flds
[0]

286 , 
	g_flds
[1]);

287 
	glf
->
SAligdPorInIlFld
(0, 
wcbd
);

288 
	gv8
::
PsitBa
<
T
>::
SWk
(

289 
ic_
<
WkClbackInfo
<
P
>*>(0)

290 , 
WkClbackInfo
<
P
>::
me
 
vokwofld
<
ue
>

291 , 
ty
);

294 #i
NODE_MODULE_VERSION
 > 
IOJS_1_1_MODULE_VERSION


295 
	gme
<
tyme
 
	gT
,ym
	gM
>

296 
	gme
<
tyme
 
	gP
>

297 
le
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

298 
P
 *
m


299 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


300 , 
WkClbackTy
 
ty
) {

301 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

302 i(
	gty
 =
WkClbackTy
::
kPam
) {

303 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

304 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

305 , 
	gback


306 , 
	gm
);

307 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

308 
wcbd


309 , 
WkClbackInfo
<
P
>::
vokam
);

311 
	gv8
::
Lol
<
v8
::
Vue
>* 
lf_v
(
t_
<v8::Lol<v8::Vue>*>(
this
));

312 
as
((*
lf_v
)->
IsObje
());

313 
	gv8
::
Lol
<
v8
::
Obje
> 
lf
((*
lf_v
).
As
<v8::Object>());

314 
	gcou
 = 
lf
->
IlFldCou
();

315 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

316 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

317 
	g_flds
[
i
] = 
lf
->
GAligdPorFromIlFld
(i);

319 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

320 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

321 , 
	gback


323 , 
	g_flds
[0]

324 , 
	g_flds
[1]);

325 
	glf
->
SAligdPorInIlFld
(0, 
wcbd
);

326 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

327 
ic_
<
WkClbackInfo
<
P
>*>(0)

328 , 
WkClbackInfo
<
P
>::
vokwofld


330 , 
cou
 > 1 ? 1 : 
kNoIlFldIndex
);

333 #i
NODE_MODULE_VERSION
 > 
NODE_0_12_MODULE_VERSION


334 
	gme
<
tyme
 
	gT
,ym
	gM
>

335 
	gme
<
tyme
 
	gP
>

336 
le
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

337 
P
 *
m


338 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


339 , 
WkClbackTy
 
ty
) {

340 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

341 i(
	gty
 =
WkClbackTy
::
kPam
) {

342 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

343 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

344 , 
	gback


345 , 
	gm
);

346 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

347 
wcbd


348 , 
WkClbackInfo
<
P
>::
vokam
);

350 
	gv8
::
Lol
<
v8
::
Vue
>* 
lf_v
(
t_
<v8::Lol<v8::Vue>*>(
this
));

351 
as
((*
lf_v
)->
IsObje
());

352 
	gv8
::
Lol
<
v8
::
Obje
> 
lf
((*
lf_v
).
As
<v8::Object>());

353 
	gcou
 = 
lf
->
IlFldCou
();

354 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

355 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

356 
	g_flds
[
i
] = 
lf
->
GAligdPorFromIlFld
(i);

358 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

359 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

360 , 
	gback


362 , 
	g_flds
[0]

363 , 
	g_flds
[1]);

364 
	glf
->
SAligdPorInIlFld
(0, 
wcbd
);

365 
	gv8
::
PsitBa
<
T
>::
SPhtom
(

366 
WkClbackInfo
<
P
>::
vokwofld


368 , 
cou
 > 1 ? 1 : 
kNoIlFldIndex
);

371 #i
NODE_MODULE_VERSION
 > 
NODE_0_10_MODULE_VERSION


372 
	gme
<
tyme
 
	gT
,ym
	gM
>

373 
	gme
<
tyme
 
	gP
>

374 
le
 
	gPsit
<
	gT
, 
	gM
>::
SWk
(

375 
P
 *
m


376 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


377 , 
WkClbackTy
 
ty
) {

378 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

379 i(
	gty
 =
WkClbackTy
::
kPam
) {

380 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

381 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

382 , 
	gback


383 , 
	gm
);

384 
	gv8
::
PsitBa
<
T
>::
SWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

386 
	gv8
::
Lol
<
v8
::
Vue
>* 
lf_v
(
t_
<v8::Lol<v8::Vue>*>(
this
));

387 
as
((*
lf_v
)->
IsObje
());

388 
	gv8
::
Lol
<
v8
::
Obje
> 
lf
((*
lf_v
).
As
<v8::Object>());

389 
	gcou
 = 
lf
->
IlFldCou
();

390 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

391 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

392 
	g_flds
[
i
] = 
lf
->
GAligdPorFromIlFld
(i);

394 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

395 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

396 , 
	gback


398 , 
	g_flds
[0]

399 , 
	g_flds
[1]);

400 
	gv8
::
PsitBa
<
T
>::
SWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

404 
	gme
<
tyme
 
	gT
>

405 
	gme
<
tyme
 
	gP
>

406 
le
 
	gPsitBa
<
	gT
>::
SWk
(

407 
P
 *
m


408 , 
tyme
 
WkClbackInfo
<
P
>::
Clback
 
back


409 , 
WkClbackTy
 
ty
) {

410 
	gWkClbackInfo
<
	gP
> *
	gwcbd
;

411 i(
	gty
 =
WkClbackTy
::
kPam
) {

412 
wcbd
 = 
w
 
WkClbackInfo
<
P
>(

413 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

414 , 
	gback


415 , 
	gm
);

416 
	grsit
.
MakeWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

418 
	gv8
::
Lol
<
v8
::
Vue
>* 
lf_v
(
t_
<v8::Lol<v8::Vue>*>(
this
));

419 
as
((*
lf_v
)->
IsObje
());

420 
	gv8
::
Lol
<
v8
::
Obje
> 
lf
((*
lf_v
).
As
<v8::Object>());

421 
	gcou
 = 
lf
->
IlFldCou
();

422 *
	g_flds
[
kIlFldsInWkClback
] = {0, 0};

423 
	gi
 = 0; i < 
	gcou
 && i < 
	gkIlFldsInWkClback
; i++) {

424 
	g_flds
[
i
] = 
lf
->
GPorFromIlFld
(i);

426 
	gwcbd
 = 
w
 
WkClbackInfo
<
P
>(

427 
t_
<
Psit
<
v8
::
Vue
>*>(
this
)

428 , 
	gback


430 , 
	g_flds
[0]

431 , 
	g_flds
[1]);

432 
	grsit
.
MakeWk
(
wcbd
, 
WkClbackInfo
<
P
>::
voke
);

	@
1
.
0
21
2012
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_callbacks.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_callbacks_12_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_callbacks_pre_12_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_converters.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_converters_43_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_converters_pre_43_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_define_own_property_helper.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_implementation_12_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_implementation_pre_12_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_json.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_maybe_43_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_maybe_pre_43_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_new.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_object_wrap.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_persistent_12_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_persistent_pre_12_inl.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_private.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_string_bytes.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_typedarray_contents.h
/Users/matthew.hoggan/Devel/sandbox/webdev/react-tutorial/node_modules/nan/nan_weak.h
